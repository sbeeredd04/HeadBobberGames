<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Prismatrix with Collisions & Obstacles</title>
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&family=Share+Tech+Mono&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="gameTitle">Prismatrix</div>
  <div id="scoreBoard"></div>
  <div id="startOverlay">
    <h1 style="font-size:64px;margin:0;">Prismatrix</h1>
    <button id="startBtn">Start Game</button>
  </div>
  <div id="gameOverOverlay">
    <h1 id="gameOverText"></h1>
    <button id="retryBtn">Retry</button>
  </div>
  <!-- Key Bindings Modal -->
  <div id="keyBindingsOverlay">
    <div id="keyBindingsModal">
      <h2>Key Bindings</h2>
      <div id="keyBindingsList"></div>
      <div class="modal-buttons">
        <button id="saveKeyBindingsBtn">Save Changes</button>
        <button id="resetDefaultsBtn">Reset to Defaults</button>
        <button id="cancelKeyBindingsBtn">Cancel</button>
      </div>
    </div>
  </div>
  <div id="settingsGear">⚙</div>
  <div id="settingsMenu">
    <fieldset><legend>Appearance</legend>
      <div id="playerColors"></div>
      <label>Obstacle Color: <input type="color" id="obsColorPicker" value="#ffff00"></label>
      <label>Background: <select id="bgSelect">
        <option value="none">None</option>
      </select></label>
    </fieldset>
    <fieldset><legend>Gameplay</legend>
      <div id="playerSettings"></div>
    </fieldset>
    <fieldset><legend>Arena & Camera</legend>
      <label>Arena Size: <input type="range" id="arenaSizeSlider" min="400" max="4000" step="10" value="800"><span id="arenaSizeValue">800</span></label>
      <label>Camera Zoom: <input type="range" id="cameraZoomSlider" min="10" max="200" step="1" value="30"><span id="cameraZoomValue">30</span></label>
    </fieldset>
    <fieldset><legend>Difficulty</legend>
      <label>Obstacle Density: <select id="levelSelect">
        <option value="5">Very Easy (5%)</option>
        <option value="10">Easy (10%)</option>
        <option value="15" selected>Medium (15%)</option>
        <option value="20">Hard (20%)</option>
        <option value="25">Insane (25%)</option>
      </select></label>
    </fieldset>
    <fieldset><legend>Actions</legend>
      <button id="saveSettingsBtn">Save Settings</button>
      <button id="exitBtn">Exit Game</button>
      <button id="keyBindingsBtn">Key Bindings</button>
      <button id="pauseBtn">Pause</button>
      <button id="resumeBtn">Resume</button>
      <button id="restartBtn">Reset</button>
    </fieldset>
  </div>
  <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
  <script>
    // ─── Setup & State ─────────────────────────────────────
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor(0x000000, 0);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Load players from localStorage
    const players = JSON.parse(localStorage.getItem('prismatrixPlayers')) || [];
    if (players.length < 2 || players.length > 5) {
      window.location.href = 'playerSetup.html';
    }

    // Default keybindings for each player
    const playerDefaultKeybindings = [
      { // P1
        left: 'KeyA',
        right: 'KeyD',
        jump: 'KeyW',
        camUp: 'KeyQ',
        camDown: 'KeyE'
      },
      { // P2
        left: 'ArrowLeft',
        right: 'ArrowRight',
        jump: 'ArrowUp',
        camUp: 'Slash',
        camDown: 'Period'
      },
      { // P3
        left: 'KeyJ',
        right: 'KeyL',
        jump: 'KeyI',
        camUp: 'KeyU',
        camDown: 'KeyO'
      },
      { // P4
        left: 'KeyF',
        right: 'KeyH',
        jump: 'KeyT',
        camUp: 'KeyR',
        camDown: 'KeyY'
      },
      { // P5
        left: 'Numpad4',
        right: 'Numpad6',
        jump: 'Numpad5',
        camUp: 'Numpad7',
        camDown: 'Numpad9'
      }
    ];

    // Ensure each player has correct keybindings
    players.forEach((player, index) => {
      if (player.type === 'keyboard') {
        player.keymap = { ...playerDefaultKeybindings[index] };
      }
    });

    // Save players to localStorage
    localStorage.setItem('prismatrixPlayers', JSON.stringify(players));

    // Game state variables
    let gameState = 'start'; // 'start', 'running', 'paused', 'gameover'
    let gameOver = false;
    let turnSpeed = 0.04;
    let camDistance = 30;
    const jumpDuration = 500;
    let obsColor = 0xffff00; // Default obstacle color
    let trailDuration = 5000; // Default trail duration in milliseconds
    let activePlayers = []; // Track which players are still active

    // Dynamic viewport layouts
    const layouts = {
      2: [{x:0,y:0,w:0.5,h:1}, {x:0.5,y:0,w:0.5,h:1}],
      3: [{x:0,y:0,w:0.5,h:0.5}, {x:0.5,y:0,w:0.5,h:0.5}, {x:0.25,y:0.5,w:0.5,h:0.5}],
      4: [{x:0,y:0,w:0.5,h:0.5}, {x:0.5,y:0,w:0.5,h:0.5}, {x:0,y:0.5,w:0.5,h:0.5}, {x:0.5,y:0.5,w:0.5,h:0.5}],
      5: [{x:0.3,y:0.3,w:0.4,h:0.4}, {x:0,y:0,w:0.3,h:0.3}, {x:0.7,y:0,w:0.3,h:0.3}, {x:0,y:0.7,w:0.3,h:0.3}, {x:0.7,y:0.7,w:0.3,h:0.3}]
    };

    // Create cameras and cycles for each player
    const cameras = [];
    const cycles = [];
    const turns = [];
    const jumps = [];
    const camHeights = [];
    const speeds = [];
    const jumpHeights = [];
    const scores = [];
    const channels = [];
    const isActive = []; // Track if each player is still active

    const defaultColors = [0x00ff00, 0xff0000, 0x0000ff, 0xffff00, 0xff00ff];
    // Starting positions for players - spread out and facing outward
    const spawnPoints = [
      // For 2-5 players, positioned in a larger circle facing outward
      {x: -100, z: 0, rotation: 0}, // P1 - Left, facing right
      {x: 100, z: 0, rotation: Math.PI}, // P2 - Right, facing left
      {x: 0, z: -100, rotation: Math.PI/2}, // P3 - Top, facing down
      {x: -70, z: 70, rotation: -Math.PI/4}, // P4 - Top-left, facing bottom-right
      {x: 70, z: 70, rotation: -3*Math.PI/4} // P5 - Top-right, facing bottom-left
    ];

    players.forEach((player, index) => {
      // Camera
      const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
      cameras.push(camera);
      
      // Cycle with updated starting position and rotation
      const cycle = makeCycle(defaultColors[index]);
      cycle.position.set(spawnPoints[index].x, 0.5, spawnPoints[index].z);
      cycle.rotation.y = spawnPoints[index].rotation;
      cycles.push(cycle);
      
      // State
      turns.push(0);
      jumps.push(0);
      camHeights.push(20);
      speeds.push(0.7);
      jumpHeights.push(2);
      scores.push(0);
      isActive.push(true);
      
      // Mobile controller channel
      if (player.type === 'phone') {
        const channel = new BroadcastChannel(`prismatrix-${player.id}`);
        channel.onmessage = e => handleMobileInput(index, e.data);
        channels.push(channel);
      }
    });

    // Update scoreboard
    function updateScoreboard() {
      const scoreText = players.map((p, i) => `P${i+1}: ${scores[i]}${!isActive[i] ? ' (Eliminated)' : ''}`).join(' | ');
      document.getElementById('scoreBoard').textContent = scoreText;
    }

    // Handle mobile input
    function handleMobileInput(playerIndex, data) {
      switch(data.action) {
        case 'move':
          turns[playerIndex] = Math.sign(data.value);
          break;
        case 'jump':
          if (Date.now() - jumps[playerIndex] > jumpDuration) {
            jumps[playerIndex] = Date.now();
          }
          break;
        case 'camUp':
          camHeights[playerIndex] = Math.min(camHeights[playerIndex] + 2, BOX - 10);
          break;
        case 'camDown':
          camHeights[playerIndex] = Math.max(camHeights[playerIndex] - 2, 5);
          break;
        case 'left':
          turns[playerIndex] = 1;
          break;
        case 'right':
          turns[playerIndex] = -1;
          break;
      }
    }

    // Keybindings UI
    document.getElementById('keyBindingsBtn').onclick = () => {
      showKeybindingsModal();
    };

    document.getElementById('cancelKeyBindingsBtn').onclick = () => {
      hideKeybindingsModal();
    };

    document.getElementById('saveKeyBindingsBtn').onclick = () => {
      saveKeybindings();
      hideKeybindingsModal();
    };

    function showKeybindingsModal() {
      const keyBindingsList = document.getElementById('keyBindingsList');
      keyBindingsList.innerHTML = '';
      
      // Create keybinding UI for each keyboard player
      players.forEach((player, index) => {
        if (player.type !== 'keyboard') return;
        
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-keybindings';
        playerDiv.innerHTML = `
          <h3>Player ${index + 1} Controls</h3>
          <div class="keybinding-row">
            <span>Turn Left</span>
            <button class="key-button" data-player="${index}" data-action="left">${player.keymap.left}</button>
          </div>
          <div class="keybinding-row">
            <span>Turn Right</span>
            <button class="key-button" data-player="${index}" data-action="right">${player.keymap.right}</button>
          </div>
          <div class="keybinding-row">
            <span>Jump</span>
            <button class="key-button" data-player="${index}" data-action="jump">${player.keymap.jump}</button>
          </div>
          <div class="keybinding-row">
            <span>Camera Up</span>
            <button class="key-button" data-player="${index}" data-action="camUp">${player.keymap.camUp}</button>
          </div>
          <div class="keybinding-row">
            <span>Camera Down</span>
            <button class="key-button" data-player="${index}" data-action="camDown">${player.keymap.camDown}</button>
          </div>
        `;
        keyBindingsList.appendChild(playerDiv);
      });

      // Add modal buttons
      const buttonsDiv = document.createElement('div');
      buttonsDiv.className = 'modal-buttons';
      buttonsDiv.innerHTML = `
        <button id="saveKeyBindingsBtn">Save Changes</button>
        <button id="resetDefaultsBtn">Reset to Defaults</button>
        <button id="cancelKeyBindingsBtn">Cancel</button>
      `;
      keyBindingsList.appendChild(buttonsDiv);
      
      // Add event listeners
      addKeyBindingListeners();
      
      // Show the modal
      document.getElementById('keyBindingsOverlay').style.display = 'flex';
    }

    function addKeyBindingListeners() {
      // Add event listeners to key buttons
      document.querySelectorAll('.key-button').forEach(button => {
        button.addEventListener('click', () => {
          // Remove waiting state from any other buttons
          document.querySelectorAll('.key-button').forEach(btn => {
            btn.classList.remove('waiting-for-key');
            btn.dataset.waiting = 'false';
          });
          
          // Highlight the button to show it's waiting for input
          button.classList.add('waiting-for-key');
          button.textContent = 'PRESS ANY KEY';
          button.dataset.waiting = 'true';
        });
      });

      // Add event listeners for modal buttons
      document.getElementById('saveKeyBindingsBtn').addEventListener('click', () => {
        saveKeybindings();
        hideKeybindingsModal();
      });

      document.getElementById('resetDefaultsBtn').addEventListener('click', () => {
        players.forEach((player, index) => {
          if (player.type === 'keyboard') {
            player.keymap = { ...playerDefaultKeybindings[index] };
          }
        });
        showKeybindingsModal(); // Refresh the modal
      });

      document.getElementById('cancelKeyBindingsBtn').addEventListener('click', hideKeybindingsModal);
    }

    function hideKeybindingsModal() {
      document.getElementById('keyBindingsOverlay').style.display = 'none';
      
      // Remove any waiting-for-key state
      document.querySelectorAll('.key-button').forEach(button => {
        button.classList.remove('waiting-for-key');
        button.dataset.waiting = 'false';
      });
    }

    function saveKeybindings() {
      // Save the current keybindings to localStorage
      localStorage.setItem('prismatrixPlayers', JSON.stringify(players));
    }

    // Add a global keydown event listener for keybinding changes
    window.addEventListener('keydown', e => {
      // Check if we're waiting for a key for keybinding
      const waitingButton = document.querySelector('.key-button[data-waiting="true"]');
      if (waitingButton) {
        e.preventDefault();
        
        // Get the player and action from the button
        const playerIndex = parseInt(waitingButton.dataset.player);
        const action = waitingButton.dataset.action;
        
        // Update the keybinding
        players[playerIndex].keymap[action] = e.code;
        
        // Update the button text
        waitingButton.textContent = e.code;
        
        // Remove the waiting state
        waitingButton.classList.remove('waiting-for-key');
        waitingButton.dataset.waiting = 'false';
        
        return;
      }
      
      // Check if this is a start game key press
      if (gameState === 'start' && e.code === 'Enter') {
        document.getElementById('startBtn').onclick();
        return;
      }
      
      // Check if this is a pause/resume key press
      if ((gameState === 'running' || gameState === 'paused') && e.code === 'Space') {
        if (gameState === 'running') {
          document.getElementById('pauseBtn').onclick();
        } else if (gameState === 'paused') {
          document.getElementById('resumeBtn').onclick();
        }
        return;
      }
      
      // Only process game controls if game is running
      if (gameState !== 'running') return;
      
      players.forEach((player, index) => {
        if (player.type !== 'keyboard') return;
        
        // Check if the pressed key matches any of the player's keybindings
        if (e.code === player.keymap.left) turns[index] = 1;
        else if (e.code === player.keymap.right) turns[index] = -1;
        else if (e.code === player.keymap.jump && Date.now() - jumps[index] > jumpDuration) {
          jumps[index] = Date.now();
        }
        else if (e.code === player.keymap.camUp) camHeights[index] = Math.min(camHeights[index] + 2, BOX - 10);
        else if (e.code === player.keymap.camDown) camHeights[index] = Math.max(camHeights[index] - 2, 5);
      });
    });

    window.addEventListener('keyup', e => {
      if (gameState !== 'running') return;
      
      players.forEach((player, index) => {
        if (player.type !== 'keyboard') return;
        if (e.code === player.keymap.left && turns[index] > 0) turns[index] = 0;
        else if (e.code === player.keymap.right && turns[index] < 0) turns[index] = 0;
      });
    });

    // ─── Lighting ──────────────────────────────────────────
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 20, 7.5);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0x404040));

    // ─── Arena ─────────────────────────────────────────────
    let BOX = 800; // Default arena size
    let half = BOX / 2;
    const boxGeo = new THREE.BoxGeometry(BOX, BOX, BOX);
    const boxMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true });
    const boundary = new THREE.Mesh(boxGeo, boxMat);
    boundary.position.set(0, half - 0.5, 0);
    scene.add(boundary);
    let gridHelper = new THREE.GridHelper(BOX, BOX / 10, 0x00ffff, 0x222222);
    scene.add(gridHelper);

    // ─── Light‑cycle factory ─────────────────────────────
    function makeCycle(color) {
      const group = new THREE.Group();
      
      // Create collision meshes (invisible)
      const collisionBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.6, 1.8),
        new THREE.MeshBasicMaterial({ visible: false })
      );
      collisionBody.name = 'collisionBody';
      group.add(collisionBody);

      const collisionHead = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.4, 0.3),
        new THREE.MeshBasicMaterial({ visible: false })
      );
      collisionHead.position.set(0, 0, -0.8);
      collisionHead.name = 'collisionHead';
      group.add(collisionHead);

      // Main body - dark metallic frame
      const bodyGeo = new THREE.BoxGeometry(0.4, 0.3, 1.8);
      const bodyMat = new THREE.MeshStandardMaterial({ 
        color: 0x111111, // Dark base color
        metalness: 0.9,
        roughness: 0.3,
        envMapIntensity: 1.5
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.15; // Slight lift for wheel clearance
      body.name = 'visualBody';
      group.add(body);

      // Wheels - larger and touching ground
      const wheelGeo = new THREE.TorusGeometry(0.4, 0.05, 16, 32); // Bigger radius, thinner profile
      const wheelMat = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.8,
        metalness: 0.9,
        roughness: 0.1
      });

      // Front wheel
      const frontWheel = new THREE.Mesh(wheelGeo, wheelMat);
      frontWheel.rotation.y = Math.PI / 2;
      frontWheel.position.set(0, 0, -0.7);
      group.add(frontWheel);

      // Back wheel
      const backWheel = new THREE.Mesh(wheelGeo, wheelMat);
      backWheel.rotation.y = Math.PI / 2;
      backWheel.position.set(0, 0, 0.7);
      group.add(backWheel);

      // Neon effect strips
      const glowMat = new THREE.MeshBasicMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 1
      });

      // Side neon strips
      [-0.22, 0.22].forEach(x => {
        const strip = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.1, 1.6),
          glowMat
        );
        strip.position.set(x, 0.2, 0);
        group.add(strip);
      });

      // Top neon strip
      const topStrip = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.02, 1.6),
        glowMat
      );
      topStrip.position.set(0, 0.31, 0);
      group.add(topStrip);

      // Front neon accent
      const frontAccent = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 0.15, 0.02),
        glowMat
      );
      frontAccent.position.set(0, 0.2, -0.9);
      group.add(frontAccent);

      // Wheel connection beams (minimal)
      const beamGeo = new THREE.BoxGeometry(0.1, 0.1, 1.4);
      const beamMat = new THREE.MeshStandardMaterial({
        color: 0x222222,
        metalness: 0.9,
        roughness: 0.3
      });
      const beam = new THREE.Mesh(beamGeo, beamMat);
      beam.position.y = 0;
      group.add(beam);

      // Add point lights for neon glow effect
      [-0.7, 0.7].forEach(z => {
        const light = new THREE.PointLight(color, 0.5, 1);
        light.position.set(0, 0.2, z);
        group.add(light);
      });

      // Position above ground
      group.position.y = 0.4; // Lower to ground
      
      scene.add(group);
      return group;
    }

    // ─── Trail & segment management ──────────────────────
    const trailSegments = [];
    function makeSegment(start, end, color, owner) {
      const length = start.distanceTo(end);
      const cyl = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, length, 8),
        new THREE.MeshStandardMaterial({ color })
      );
      cyl.position.copy(start).add(end).multiplyScalar(0.5);
      cyl.lookAt(end);
      cyl.rotateX(Math.PI / 2);
      cyl.userData.birth = Date.now();
      cyl.userData.owner = owner;
      scene.add(cyl);
      trailSegments.push(cyl);
    }

    // ─── Obstacles ─────────────────────────────────────────
    const obstacles = [];
    const obsGeo = new THREE.BoxGeometry(4, 4, 4);
    const obsMat = new THREE.MeshStandardMaterial({ color: obsColor });
    let obstaclePercent = 15; // Default obstacle density

    function generateObstacles() {
      obstacles.forEach(o => scene.remove(o));
      obstacles.length = 0;
      const count = Math.floor(BOX * obstaclePercent / 100);
      for (let i = 0; i < count; i++) {
        const obs = new THREE.Mesh(obsGeo, new THREE.MeshStandardMaterial({ color: obsColor }));
        obs.position.set((Math.random() - 0.5) * (BOX - 20), 2, (Math.random() - 0.5) * (BOX - 20));
        scene.add(obs);
        obstacles.push(obs);
      }
    }
    // initial generate
    generateObstacles();

    // ─── Collision Detection ─────────────────────────────
    function detectCollision(cycle, owner) {
      // Get collision meshes
      const collisionBody = cycle.getObjectByName('collisionBody');
      const collisionHead = cycle.getObjectByName('collisionHead');
      
      // Update world matrices for accurate bounds
      cycle.updateMatrixWorld(true);
      collisionBody.updateMatrixWorld(true);
      collisionHead.updateMatrixWorld(true);
      
      // Create bounding boxes for body and head
      const bodyBox = new THREE.Box3().setFromObject(collisionBody);
      const headBox = new THREE.Box3().setFromObject(collisionHead);
      
      // Get cycle dimensions for precise boundary checking
      const cycleSize = new THREE.Vector3();
      bodyBox.getSize(cycleSize);
      
      // Out of bounds check with precise dimensions
      if (Math.abs(cycle.position.x) > half - cycleSize.x/2 || 
          Math.abs(cycle.position.z) > half - cycleSize.z/2) {
        return {
          collision: true,
          type: 'boundary',
          point: cycle.position.clone()
        };
      }
      
      // Obstacle collision with separate checks for body and head
      for (let obs of obstacles) {
        obs.updateMatrixWorld(true);
        const obsBox = new THREE.Box3().setFromObject(obs);
        
        if (bodyBox.intersectsBox(obsBox) || headBox.intersectsBox(obsBox)) {
          return {
            collision: true,
            type: 'obstacle',
            point: obs.position.clone()
          };
        }
      }
      
      // Trail collision with improved precision
      const now = Date.now();
      for (let seg of trailSegments) {
        // Skip segments that are too new or owned by current player
        if (now - seg.userData.birth < 50) continue;
        if (seg.userData.owner === owner) continue;
        
        seg.updateMatrixWorld(true);
        const segBox = new THREE.Box3().setFromObject(seg);
        
        // Check both body and head collisions with trails
        if (bodyBox.intersectsBox(segBox) || headBox.intersectsBox(segBox)) {
          return {
            collision: true,
            type: 'trail',
            point: seg.position.clone(),
            owner: seg.userData.owner
          };
        }
      }
      
      // Player-to-player collision detection
      for (let i = 0; i < cycles.length; i++) {
        const otherCycle = cycles[i];
        if (!isActive[i] || otherCycle === cycle) continue;
        
        otherCycle.updateMatrixWorld(true);
        const otherBody = otherCycle.getObjectByName('collisionBody');
        const otherHead = otherCycle.getObjectByName('collisionHead');
        
        if (!otherBody || !otherHead) continue;
        
        const otherBodyBox = new THREE.Box3().setFromObject(otherBody);
        const otherHeadBox = new THREE.Box3().setFromObject(otherHead);
        
        // Check all possible collision combinations
        if (bodyBox.intersectsBox(otherBodyBox) || 
            bodyBox.intersectsBox(otherHeadBox) || 
            headBox.intersectsBox(otherBodyBox) || 
            headBox.intersectsBox(otherHeadBox)) {
          return {
            collision: true,
            type: 'player',
            point: otherCycle.position.clone(),
            otherPlayer: i + 1
          };
        }
      }
      
      return { collision: false };
    }

    // ─── Animation loop ──────────────────────────────────
    function animate() {
      requestAnimationFrame(animate);
      if (gameState === 'running' && !gameOver) {
        const now = Date.now();
        
        // Update each player
        players.forEach((player, index) => {
          // Skip inactive players
          if (!isActive[index]) return;
          
          const cycle = cycles[index];
          const jumping = now - jumps[index] < jumpDuration;
          
          // Update vertical position for jump
          const height = jumping ? 0.5 + jumpHeights[index] * Math.sin(Math.PI * (now - jumps[index])/jumpDuration) : 0.5;
          cycle.position.y = height;
          
          // Movement and trail
          cycle.rotation.y += turns[index] * turnSpeed;
          cycle.rotation.z = turns[index] * Math.PI / 8;
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cycle.quaternion).multiplyScalar(speeds[index]);
          const oldPos = cycle.position.clone();
          cycle.position.add(forward);
          
          // Create trail segment for all movement
          makeSegment(oldPos, cycle.position, defaultColors[index], `p${index+1}`);
          
          // Camera follow
          const behind = forward.clone().normalize().multiplyScalar(-camDistance);
          const camPos = cycle.position.clone()
            .add(behind)
            .setY(cycle.position.y + camHeights[index]);
          cameras[index].position.lerp(camPos, 0.1);
          cameras[index].lookAt(cycle.position);
          
          // Collision detection
          if (!jumping) {
            const collisionResult = detectCollision(cycle, `p${index+1}`);
            if (collisionResult.collision) {
              // Eliminate this player
              isActive[index] = false;
              
              // Create explosion effect at collision point
              createExplosion(collisionResult.point, defaultColors[index]);
              
              // Notify the eliminated player
              if (player.type === 'phone') {
                notifyController(index, {
                  type: 'playerEliminated',
                  playerId: index + 1,
                  collisionType: collisionResult.type,
                  otherPlayer: collisionResult.otherPlayer
                });
              }
              
              // Check if only one player remains
              const activeCount = isActive.filter(active => active).length;
              if (activeCount <= 1) {
                const winnerIndex = isActive.findIndex(active => active);
                if (winnerIndex !== -1) {
                  scores[winnerIndex]++;
                  updateScoreboard();
                  gameOverText.innerText = `Player ${winnerIndex + 1} Wins!`;
                  endGame(`p${winnerIndex + 1}`);
                } else {
                  gameOverText.innerText = "Game Over - No Winner";
                  endGame(null);
                }
              } else {
                updateScoreboard();
              }
            }
          }
        });
        
        // Clean up old trail segments
        for (let i = trailSegments.length - 1; i >= 0; i--) {
          const seg = trailSegments[i];
          if (now - seg.userData.birth > trailDuration) {
            scene.remove(seg);
            trailSegments.splice(i, 1);
          }
        }
      }
      
      // Render viewports
      renderer.setScissorTest(true);
      layouts[players.length].forEach((vp, idx) => {
        const Cx = innerWidth * vp.x;
        const Cy = innerHeight * (1 - vp.y - vp.h);
        const Cw = innerWidth * vp.w;
        const Ch = innerHeight * vp.h;
        renderer.setViewport(Cx, Cy, Cw, Ch);
        renderer.setScissor(Cx, Cy, Cw, Ch);
        renderer.render(scene, cameras[idx]);
      });
      renderer.setScissorTest(false);
    }

    // Add explosion effect function
    function createExplosion(position, color) {
      const particleCount = 50;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const velocities = [];
      
      for (let i = 0; i < particleCount; i++) {
        positions.push(
          position.x + (Math.random() - 0.5) * 0.5,
          position.y + (Math.random() - 0.5) * 0.5,
          position.z + (Math.random() - 0.5) * 0.5
        );
        
        velocities.push(
          (Math.random() - 0.5) * 0.2,
          Math.random() * 0.2,
          (Math.random() - 0.5) * 0.2
        );
      }
      
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      
      const material = new THREE.PointsMaterial({
        color: color,
        size: 0.2,
        transparent: true,
        opacity: 1
      });
      
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      // Animate explosion
      const startTime = Date.now();
      const duration = 1000; // 1 second
      
      function animateExplosion() {
        const positions = particles.geometry.attributes.position.array;
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          scene.remove(particles);
          return;
        }
        
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          positions[i3] += velocities[i3] * (1 - progress);
          positions[i3 + 1] += velocities[i3 + 1] * (1 - progress);
          positions[i3 + 2] += velocities[i3 + 2] * (1 - progress);
        }
        
        particles.geometry.attributes.position.needsUpdate = true;
        material.opacity = 1 - progress;
        
        requestAnimationFrame(animateExplosion);
      }
      
      animateExplosion();
    }

    // Create dynamic player settings UI
    function createPlayerSettingsUI() {
      const playerColors = document.getElementById('playerColors');
      const playerSettings = document.getElementById('playerSettings');
      
      players.forEach((player, index) => {
        // Color picker
        const colorDiv = document.createElement('div');
        colorDiv.className = 'player-color';
        colorDiv.innerHTML = `
          <label>Player ${index + 1} Color:</label>
          <input type="color" id="p${index+1}ColorPicker" value="#${defaultColors[index].toString(16).padStart(6, '0')}">
        `;
        playerColors.appendChild(colorDiv);
        
        // Speed and jump height controls
        const settingsDiv = document.createElement('div');
        settingsDiv.className = 'player-settings';
        settingsDiv.innerHTML = `
          <h3>Player ${index + 1}</h3>
          <div class="player-speed">
            <label>Speed:</label>
            <input type="range" id="p${index+1}SpeedSlider" min="0.1" max="5" step="0.1" value="0.7">
            <span id="p${index+1}SpeedValue">0.7</span>
          </div>
          <div class="player-jump">
            <label>Jump Height:</label>
            <input type="range" id="p${index+1}JumpHeightSlider" min="0.1" max="20" step="0.1" value="2">
            <span id="p${index+1}JumpHeightValue">2</span>
          </div>
        `;
        playerSettings.appendChild(settingsDiv);
        
        // Add event listeners
        const colorPicker = document.getElementById(`p${index+1}ColorPicker`);
        const speedSlider = document.getElementById(`p${index+1}SpeedSlider`);
        const jumpHeightSlider = document.getElementById(`p${index+1}JumpHeightSlider`);
        
        colorPicker.oninput = () => {
          const color = parseInt(colorPicker.value.slice(1), 16);
          cycles[index].traverse(c => {
        if (c.isMesh) {
              c.material.color.set(colorPicker.value);
              if (c.material.emissive) c.material.emissive.set(colorPicker.value);
        }
      });
    };
        
        speedSlider.oninput = () => {
          speeds[index] = parseFloat(speedSlider.value);
          document.getElementById(`p${index+1}SpeedValue`).textContent = speedSlider.value;
        };
        
        jumpHeightSlider.oninput = () => {
          jumpHeights[index] = parseFloat(jumpHeightSlider.value);
          document.getElementById(`p${index+1}JumpHeightValue`).textContent = jumpHeightSlider.value;
        };
      });
      
      // Add trail duration control
      const trailSettingsDiv = document.createElement('div');
      trailSettingsDiv.className = 'trail-settings';
      trailSettingsDiv.innerHTML = `
        <h3>Trail Settings</h3>
        <div class="trail-duration">
          <label>Trail Duration (seconds):</label>
          <input type="range" id="trailDurationSlider" min="1" max="30" step="1" value="${trailDuration/1000}">
          <span id="trailDurationValue">${trailDuration/1000}</span>
        </div>
      `;
      playerSettings.appendChild(trailSettingsDiv);
      
      // Add event listener for trail duration
      const trailDurationSlider = document.getElementById('trailDurationSlider');
      trailDurationSlider.oninput = () => {
        const seconds = parseInt(trailDurationSlider.value);
        trailDuration = seconds * 1000;
        document.getElementById('trailDurationValue').textContent = seconds;
      };
    }

    // Initialize settings UI
    createPlayerSettingsUI();

    // Settings menu visibility
    document.getElementById('settingsGear').onclick = () => {
      const menu = document.getElementById('settingsMenu');
      menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    };

    // Save settings
    document.getElementById('saveSettingsBtn').onclick = () => {
      document.getElementById('settingsMenu').style.display = 'none';
    };

    // Start game
    document.getElementById('startBtn').onclick = () => {
      document.getElementById('startOverlay').style.display = 'none';
      gameState = 'running';
      
      // Notify all controllers about game state change
      notifyControllers({
        type: 'gameStatus',
        gameState: gameState
      });
    };

    // Game over
    function endGame(winner) {
      gameOver = true;
      gameState = 'gameover';
      document.getElementById('gameOverOverlay').style.display = 'flex';
      
      // Notify all controllers about game over
      notifyControllers({
        type: 'gameStatus',
        gameState: gameState,
        winner: winner ? winner.replace('p', '') : null
      });
    }

    // Retry
    document.getElementById('retryBtn').onclick = () => {
      window.location.reload();
    };

    // Pause/Resume
    document.getElementById('pauseBtn').onclick = () => {
      if (gameState === 'running') {
        gameState = 'paused';
        
        // Notify all controllers about game state change
        notifyControllers({
          type: 'gameStatus',
          gameState: gameState
        });
      }
    };

    document.getElementById('resumeBtn').onclick = () => {
      if (gameState === 'paused') {
        gameState = 'running';
        
        // Notify all controllers about game state change
        notifyControllers({
          type: 'gameStatus',
          gameState: gameState
        });
      }
    };

    // Restart
    document.getElementById('restartBtn').onclick = () => {
      window.location.reload();
    };

    // Exit
    document.getElementById('exitBtn').onclick = () => {
      window.location.href = 'playerSetup.html';
    };

    // Obstacle color picker
    document.getElementById('obsColorPicker').oninput = () => {
      obsColor = parseInt(document.getElementById('obsColorPicker').value.slice(1), 16);
      obstacles.forEach(o => o.material.color.set(document.getElementById('obsColorPicker').value));
    };

    // Arena size slider
    document.getElementById('arenaSizeSlider').oninput = () => {
      BOX = parseInt(document.getElementById('arenaSizeSlider').value);
      half = BOX / 2;
      document.getElementById('arenaSizeValue').textContent = BOX;
      
      // Update boundary
      boundary.geometry.dispose();
      boundary.geometry = new THREE.BoxGeometry(BOX, BOX, BOX);
      boundary.position.set(0, half - 0.5, 0);
      
      // Update grid helper
      scene.remove(gridHelper);
      gridHelper.geometry.dispose();
      gridHelper = new THREE.GridHelper(BOX, BOX / 10, 0x00ffff, 0x222222);
      scene.add(gridHelper);
      
      // Regenerate obstacles
      generateObstacles();
    };

    // Camera zoom slider
    document.getElementById('cameraZoomSlider').oninput = () => {
      camDistance = parseFloat(document.getElementById('cameraZoomSlider').value);
      document.getElementById('cameraZoomValue').textContent = camDistance;
    };

    // Obstacle density
    document.getElementById('levelSelect').onchange = () => {
      obstaclePercent = parseInt(document.getElementById('levelSelect').value);
      generateObstacles();
    };

    // Background selection
    const bgSelect = document.getElementById('bgSelect');
    const bgFiles = [];
    for (let i = 1; i <= 23; i++) {
      bgFiles.push(`bg_ (${i}).jpeg`, `bg_ (${i}).jpg`);
    }
    bgFiles.forEach(fn => {
      const opt = document.createElement('option');
      opt.value = fn;
      opt.textContent = fn;
      bgSelect.appendChild(opt);
    });
    bgSelect.onchange = () => {
      const val = bgSelect.value;
      if (val === 'none') {
        document.body.style.backgroundImage = 'none';
      } else {
        document.body.style.backgroundImage = `url("assets/${val}")`;
      }
    };

    // Initialize game state
    gameState = 'start';
    document.getElementById('startOverlay').style.display = 'flex';
    document.getElementById('gameOverOverlay').style.display = 'none';
    document.getElementById('settingsMenu').style.display = 'none';

    // Check if all players are keyboard players - auto-start if so
    const allKeyboard = players.every(p => p.type === 'keyboard');
    if (allKeyboard) {
      document.getElementById('startBtn').onclick();
    }

    // Initialize scoreboard
    updateScoreboard();

    // Start animation
    animate();

    // Function to notify all controllers about game state changes
    function notifyControllers(message) {
      players.forEach((player, index) => {
        if (player.type === 'phone') {
          notifyController(index, message);
        }
      });
    }
    
    // Function to notify a specific controller
    function notifyController(playerIndex, message) {
      if (channels[playerIndex]) {
        channels[playerIndex].postMessage(message);
      }
    }

    // Add CSS for settings and keybindings
    const style = document.createElement('style');
    style.textContent = `
      #settingsMenu {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #0ff;
        border-radius: 10px;
        padding: 20px;
        color: #0ff;
        z-index: 900;
        max-height: 80vh;
        overflow-y: auto;
        width: 80%;
        max-width: 600px;
      }

      #keyBindingsOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: 'Share Tech Mono', monospace;
      }
      
      #keyBindingsModal {
        background: #000;
        border: 2px solid #0ff;
        border-radius: 15px;
        padding: 30px;
        max-width: 800px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        color: #0ff;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      }
      
      #keyBindingsModal h2 {
        text-align: center;
        margin: 0 0 20px 0;
        color: #0ff;
        text-shadow: 0 0 10px #0ff;
        font-size: 24px;
      }
      
      .player-keybindings {
        margin-bottom: 25px;
        padding: 20px;
        border: 1px solid #0ff;
        border-radius: 10px;
        background: rgba(0, 255, 255, 0.05);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.1) inset;
      }
      
      .player-keybindings h3 {
        margin: 0 0 15px 0;
        color: #0ff;
        text-shadow: 0 0 5px #0ff;
        font-size: 20px;
        border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        padding-bottom: 10px;
      }
      
      .keybinding-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 12px 0;
        padding: 8px 15px;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 8px;
        border: 1px solid rgba(0, 255, 255, 0.1);
      }
      
      .keybinding-row span {
        font-size: 16px;
        color: rgba(0, 255, 255, 0.9);
      }
      
      .key-button {
        background: rgba(0, 255, 255, 0.1);
        border: 1px solid #0ff;
        color: #0ff;
        padding: 8px 20px;
        border-radius: 8px;
        cursor: pointer;
        min-width: 140px;
        text-align: center;
        font-size: 16px;
        transition: all 0.3s ease;
        text-transform: uppercase;
      }
      
      .key-button:hover {
        background: rgba(0, 255, 255, 0.2);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      }
      
      .key-button.waiting-for-key {
        background: rgba(255, 255, 0, 0.2);
        border-color: #ff0;
        color: #ff0;
        animation: pulse 1s infinite;
      }
      
      @keyframes pulse {
        0% { opacity: 1; box-shadow: 0 0 15px rgba(255, 255, 0, 0.3); }
        50% { opacity: 0.5; box-shadow: 0 0 25px rgba(255, 255, 0, 0.5); }
        100% { opacity: 1; box-shadow: 0 0 15px rgba(255, 255, 0, 0.3); }
      }
      
      .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 25px;
        padding-top: 20px;
        border-top: 1px solid rgba(0, 255, 255, 0.3);
      }
      
      .modal-buttons button {
        background: rgba(0, 255, 255, 0.1);
        border: 2px solid #0ff;
        color: #0ff;
        padding: 12px 25px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
        min-width: 150px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      
      .modal-buttons button:hover {
        background: rgba(0, 255, 255, 0.2);
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        transform: translateY(-2px);
      }
      
      #saveKeyBindingsBtn {
        background: rgba(0, 255, 255, 0.2);
      }
      
      #resetDefaultsBtn {
        background: rgba(255, 165, 0, 0.1);
        border-color: #ffa500;
        color: #ffa500;
      }
      
      #cancelKeyBindingsBtn {
        background: rgba(255, 0, 0, 0.1);
        border-color: #f00;
        color: #f00;
      }
      
      /* Scrollbar styling */
      #keyBindingsModal::-webkit-scrollbar {
        width: 10px;
      }
      
      #keyBindingsModal::-webkit-scrollbar-track {
        background: rgba(0, 255, 255, 0.1);
        border-radius: 5px;
      }
      
      #keyBindingsModal::-webkit-scrollbar-thumb {
        background: rgba(0, 255, 255, 0.3);
        border-radius: 5px;
        border: 1px solid rgba(0, 255, 255, 0.5);
      }
      
      #keyBindingsModal::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 255, 255, 0.4);
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>
``` 
``` 