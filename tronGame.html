<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Prismatrix with Collisions & Obstacles</title>
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&family=Share+Tech+Mono&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="gameTitle">Prismatrix</div>
  <div id="scoreBoard"></div>
  <div id="startOverlay">
    <h1 style="font-size:64px;margin:0;">Prismatrix</h1>
    <button id="startBtn">Start Game</button>
  </div>
  <div id="gameOverOverlay">
    <h1 id="gameOverText"></h1>
    <button id="retryBtn">Retry</button>
  </div>
  <!-- Key Bindings Modal -->
  <div id="keyBindingsOverlay">
    <div id="keyBindingsModal">
      <h2>Key Bindings</h2>
      <div id="keyBindingsList"></div>
      <button id="saveKeyBindingsBtn">Save</button>
      <button id="cancelKeyBindingsBtn">Cancel</button>
    </div>
  </div>
  <div id="settingsGear">⚙</div>
  <div id="settingsMenu">
    <fieldset><legend>Appearance</legend>
      <div id="playerColors"></div>
      <label>Obstacle Color: <input type="color" id="obsColorPicker" value="#ffff00"></label>
      <label>Background: <select id="bgSelect">
        <option value="none">None</option>
      </select></label>
    </fieldset>
    <fieldset><legend>Gameplay</legend>
      <div id="playerSettings"></div>
    </fieldset>
    <fieldset><legend>Arena & Camera</legend>
      <label>Arena Size: <input type="range" id="arenaSizeSlider" min="400" max="4000" step="10" value="800"><span id="arenaSizeValue">800</span></label>
      <label>Camera Zoom: <input type="range" id="cameraZoomSlider" min="10" max="200" step="1" value="30"><span id="cameraZoomValue">30</span></label>
    </fieldset>
    <fieldset><legend>Difficulty</legend>
      <label>Obstacle Density: <select id="levelSelect">
        <option value="5">Very Easy (5%)</option>
        <option value="10">Easy (10%)</option>
        <option value="15" selected>Medium (15%)</option>
        <option value="20">Hard (20%)</option>
        <option value="25">Insane (25%)</option>
      </select></label>
    </fieldset>
    <fieldset><legend>Actions</legend>
      <button id="saveSettingsBtn">Save Settings</button>
      <button id="exitBtn">Exit Game</button>
      <button id="keyBindingsBtn">Key Bindings</button>
      <button id="pauseBtn">Pause</button>
      <button id="resumeBtn">Resume</button>
      <button id="restartBtn">Reset</button>
    </fieldset>
  </div>
  <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
  <script>
    // ─── Setup & State ─────────────────────────────────────
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor(0x000000, 0);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Load players from localStorage
    const players = JSON.parse(localStorage.getItem('prismatrixPlayers')) || [];
    if (players.length < 2 || players.length > 5) {
      window.location.href = 'playerSetup.html';
    }

    // Default keybindings
    const defaultKeybindings = {
      p1: {
        left: 'KeyA',
        right: 'KeyD',
        forward: 'KeyW',
        jump: 'KeyS',
        camUp: 'KeyQ',
        camDown: 'KeyE'
      },
      p2: {
        left: 'ArrowLeft',
        right: 'ArrowRight',
        forward: 'ArrowUp',
        jump: 'ArrowDown',
        camUp: 'Period',
        camDown: 'Slash'
      },
      p3: {
        left: 'KeyJ',
        right: 'KeyL',
        forward: 'KeyI',
        jump: 'KeyK',
        camUp: 'KeyU',
        camDown: 'KeyO'
      },
      p4: {
        left: 'KeyF',
        right: 'KeyH',
        forward: 'KeyT',
        jump: 'KeyG',
        camUp: 'KeyR',
        camDown: 'KeyY'
      },
      p5: {
        left: 'Numpad4',
        right: 'Numpad6',
        forward: 'Numpad8',
        jump: 'Numpad5',
        camUp: 'Numpad7',
        camDown: 'Numpad9'
      }
    };

    // Ensure each player has keybindings
    players.forEach((player, index) => {
      if (player.type === 'keyboard') {
        const playerNum = `p${index + 1}`;
        player.keymap = player.keymap || { ...defaultKeybindings[playerNum] };
      }
    });

    // Save players to localStorage
    localStorage.setItem('prismatrixPlayers', JSON.stringify(players));

    // Game state variables
    let gameState = 'start'; // 'start', 'running', 'paused', 'gameover'
    let gameOver = false;
    let turnSpeed = 0.04;
    let camDistance = 30;
    const jumpDuration = 500;
    let obsColor = 0xffff00; // Default obstacle color
    let trailDuration = 5000; // Default trail duration in milliseconds
    let activePlayers = []; // Track which players are still active

    // Dynamic viewport layouts
    const layouts = {
      2: [{x:0,y:0,w:0.5,h:1}, {x:0.5,y:0,w:0.5,h:1}],
      3: [{x:0,y:0,w:0.5,h:0.5}, {x:0.5,y:0,w:0.5,h:0.5}, {x:0.25,y:0.5,w:0.5,h:0.5}],
      4: [{x:0,y:0,w:0.5,h:0.5}, {x:0.5,y:0,w:0.5,h:0.5}, {x:0,y:0.5,w:0.5,h:0.5}, {x:0.5,y:0.5,w:0.5,h:0.5}],
      5: [{x:0.3,y:0.3,w:0.4,h:0.4}, {x:0,y:0,w:0.3,h:0.3}, {x:0.7,y:0,w:0.3,h:0.3}, {x:0,y:0.7,w:0.3,h:0.3}, {x:0.7,y:0.7,w:0.3,h:0.3}]
    };

    // Create cameras and cycles for each player
    const cameras = [];
    const cycles = [];
    const turns = [];
    const jumps = [];
    const camHeights = [];
    const speeds = [];
    const jumpHeights = [];
    const scores = [];
    const isActive = []; // Track if each player is still active

    const defaultColors = [0x00ff00, 0xff0000, 0x0000ff, 0xffff00, 0xff00ff];
    const spawnPoints = [
      {x: 0, z: -50, rotation: 0}, // P1 at bottom, facing down
      {x: 50, z: 0, rotation: Math.PI / 2}, // P2 at right, facing right
      {x: 0, z: 50, rotation: Math.PI}, // P3 at top, facing up
      {x: -50, z: 0, rotation: -Math.PI / 2}, // P4 at left, facing left
      {x: -35, z: -35, rotation: -Math.PI / 4} // P5 at bottom-left, facing bottom-left
    ];

    players.forEach((player, index) => {
      // Camera
      const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
      cameras.push(camera);
      
      // Cycle
      const cycle = makeCycle(defaultColors[index]);
      cycle.position.set(spawnPoints[index].x, 0.5, spawnPoints[index].z);
      cycle.rotation.y = spawnPoints[index].rotation;
      cycles.push(cycle);
      
      // State
      turns.push(0);
      jumps.push(0);
      camHeights.push(20);
      speeds.push(0.7);
      jumpHeights.push(2);
      scores.push(0);
      isActive.push(true); // All players start active
    });

    // Update scoreboard
    function updateScoreboard() {
      const scoreText = players.map((p, i) => `P${i+1}: ${scores[i]}${!isActive[i] ? ' (Eliminated)' : ''}`).join(' | ');
      document.getElementById('scoreBoard').textContent = scoreText;
    }

    // Keyboard input handling
    window.addEventListener('keydown', e => {
      // Check if this is a start game key press
      if (gameState === 'start' && e.code === 'Enter') {
        document.getElementById('startBtn').onclick();
        return;
      }
      
      // Check if this is a pause/resume key press
      if ((gameState === 'running' || gameState === 'paused') && e.code === 'Space') {
        if (gameState === 'running') {
          document.getElementById('pauseBtn').onclick();
        } else if (gameState === 'paused') {
          document.getElementById('resumeBtn').onclick();
        }
        return;
      }
      
      // Only process game controls if game is running
      if (gameState !== 'running') return;
      
      players.forEach((player, index) => {
        // Check if the pressed key matches any of the player's keybindings
        if (e.code === player.keymap.left) turns[index] = 1;
        else if (e.code === player.keymap.right) turns[index] = -1;
        else if (e.code === player.keymap.forward) speeds[index] = 0.7;
        else if (e.code === player.keymap.jump && Date.now() - jumps[index] > jumpDuration) {
          jumps[index] = Date.now();
        }
        else if (e.code === player.keymap.camUp) camHeights[index] = Math.min(camHeights[index] + 2, BOX - 10);
        else if (e.code === player.keymap.camDown) camHeights[index] = Math.max(camHeights[index] - 2, 5);
      });
    });

    window.addEventListener('keyup', e => {
      if (gameState !== 'running') return;
      
      players.forEach((player, index) => {
        if (e.code === player.keymap.forward) speeds[index] = 0;
        else if (e.code === player.keymap.left && turns[index] > 0) turns[index] = 0;
        else if (e.code === player.keymap.right && turns[index] < 0) turns[index] = 0;
      });
    });

    // ─── Lighting ──────────────────────────────────────────
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 20, 7.5);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0x404040));

    // ─── Arena ─────────────────────────────────────────────
    let BOX = 800; // Default arena size
    let half = BOX / 2;
    const boxGeo = new THREE.BoxGeometry(BOX, BOX, BOX);
    const boxMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true });
    const boundary = new THREE.Mesh(boxGeo, boxMat);
    boundary.position.set(0, half - 0.5, 0);
    scene.add(boundary);
    let gridHelper = new THREE.GridHelper(BOX, BOX / 10, 0x00ffff, 0x222222);
    scene.add(gridHelper);

    // ─── Light‑cycle factory ─────────────────────────────
    function makeCycle(color) {
      const group = new THREE.Group();
      // glowing neon chassis
      const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.6, 32, 1, true);
      bodyGeo.rotateZ(Math.PI / 2);
      const bodyMat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.6, metalness: 0.5, roughness: 0.2 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      group.add(body);
      // seat and tail extension
      const seatGeo = new THREE.BoxGeometry(0.3, 0.1, 0.5);
      const seat = new THREE.Mesh(seatGeo, bodyMat);
      seat.position.set(0, 0.15, 0);
      group.add(seat);
      const tailGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 16);
      const tail = new THREE.Mesh(tailGeo, bodyMat);
      tail.rotation.x = Math.PI/2;
      tail.position.set(0, 0.1, 0.8);
      group.add(tail);
      // neon side strips
      const stripGeo = new THREE.BoxGeometry(0.05, 0.05, 1.6);
      const stripMat = new THREE.MeshBasicMaterial({ color: color, emissive: color, emissiveIntensity: 1 });
      ['left','right'].forEach((side, i) => {
        const strip = new THREE.Mesh(stripGeo, stripMat);
        strip.position.set((side==='left'? -0.35: 0.35), 0.05, 0);
        group.add(strip);
      });
      // front fork connectors
      const forkGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8);
      const forkMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
      const fork1 = new THREE.Mesh(forkGeo, forkMat);
      fork1.position.set(0, 0, -0.4);
      fork1.rotation.x = Math.PI/2;
      group.add(fork1);
      const fork2 = fork1.clone(); fork2.position.set(0, 0.1, -0.4);
      group.add(fork2);
      // wheels: front and back
      const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 16);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.3 });
      const frontWheel = new THREE.Mesh(wheelGeo, wheelMat);
      frontWheel.rotation.z = Math.PI / 2;
      frontWheel.position.set(0, -0.1, -0.8);
      const backWheel = new THREE.Mesh(wheelGeo, wheelMat);
      backWheel.rotation.z = Math.PI / 2;
      backWheel.position.set(0, -0.1, 0.8);
      group.add(frontWheel, backWheel);
      // position above ground
      group.position.y = 0.5;
      scene.add(group);
      return group;
    }

    // ─── Trail & segment management ──────────────────────
    const trailSegments = [];
    function makeSegment(start, end, color, owner) {
      const length = start.distanceTo(end);
      const cyl = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, length, 8),
        new THREE.MeshStandardMaterial({ color })
      );
      cyl.position.copy(start).add(end).multiplyScalar(0.5);
      cyl.lookAt(end);
      cyl.rotateX(Math.PI / 2);
      cyl.userData.birth = Date.now();
      cyl.userData.owner = owner;
      scene.add(cyl);
      trailSegments.push(cyl);
    }

    // ─── Obstacles ─────────────────────────────────────────
    const obstacles = [];
    const obsGeo = new THREE.BoxGeometry(4, 4, 4);
    const obsMat = new THREE.MeshStandardMaterial({ color: obsColor });
    let obstaclePercent = 15; // Default obstacle density

    function generateObstacles() {
      obstacles.forEach(o => scene.remove(o));
      obstacles.length = 0;
      const count = Math.floor(BOX * obstaclePercent / 100);
      for (let i = 0; i < count; i++) {
        const obs = new THREE.Mesh(obsGeo, new THREE.MeshStandardMaterial({ color: obsColor }));
        obs.position.set((Math.random() - 0.5) * (BOX - 20), 2, (Math.random() - 0.5) * (BOX - 20));
        scene.add(obs);
        obstacles.push(obs);
      }
    }
    // initial generate
    generateObstacles();

    // ─── Collision Detection ─────────────────────────────
    function detectCollision(cycle, owner) {
      // out of bounds
      if (Math.abs(cycle.position.x) > half || cycle.position.z > half || cycle.position.z < -half) return true;
      
      // obstacle collision
      for (let obs of obstacles) {
        // Calculate distance between cycle and obstacle
        const distance = cycle.position.distanceTo(obs.position);
        // Check if cycle is close enough to obstacle for collision
        if (distance < 3) {
          // More precise collision detection using bounding boxes
          const cycleBox = new THREE.Box3().setFromObject(cycle);
          const obsBox = new THREE.Box3().setFromObject(obs);
          if (cycleBox.intersectsBox(obsBox)) {
            return true;
          }
        }
      }
      
      // trail collision
      const now = Date.now();
      for (let seg of trailSegments) {
        // Skip segments that are too new (just created)
        if (now - seg.userData.birth < 50) continue;
        
        // Skip segments owned by the current player
        if (seg.userData.owner === owner) continue;
        
        // Calculate distance between cycle and trail segment
        const distance = cycle.position.distanceTo(seg.position);
        if (distance < 0.7) {
          // More precise collision detection using bounding boxes
          const cycleBox = new THREE.Box3().setFromObject(cycle);
          const segBox = new THREE.Box3().setFromObject(seg);
          if (cycleBox.intersectsBox(segBox)) {
            return true;
          }
        }
      }
      
      return false;
    }

    // ─── Animation loop ──────────────────────────────────
    function animate() {
      requestAnimationFrame(animate);
      if (gameState === 'running' && !gameOver) {
        const now = Date.now();
        
        // Update each player
        players.forEach((player, index) => {
          // Skip inactive players
          if (!isActive[index]) return;
          
          const cycle = cycles[index];
          const jumping = now - jumps[index] < jumpDuration;
          
          // Update vertical position for jump
          const height = jumping ? 0.5 + jumpHeights[index] * Math.sin(Math.PI * (now - jumps[index])/jumpDuration) : 0.5;
          cycle.position.y = height;
          
          // Movement and trail
          cycle.rotation.y += turns[index] * turnSpeed;
          cycle.rotation.z = turns[index] * Math.PI / 8;
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cycle.quaternion).multiplyScalar(speeds[index]);
          const oldPos = cycle.position.clone();
          cycle.position.add(forward);
          
          // Create trail segment for all movement, not just turns
          makeSegment(oldPos, cycle.position, defaultColors[index], `p${index+1}`);
          
          // Camera follow
          const behind = forward.clone().normalize().multiplyScalar(-camDistance);
          const camPos = cycle.position.clone()
            .add(behind)
            .setY(cycle.position.y + camHeights[index]);
          cameras[index].position.lerp(camPos, 0.1);
          cameras[index].lookAt(cycle.position);
          
          // Collision detection
          if (!jumping) {
            if (detectCollision(cycle, `p${index+1}`)) {
              // Eliminate this player
              isActive[index] = false;
              
              // Check if only one player remains
              const activeCount = isActive.filter(active => active).length;
              if (activeCount <= 1) {
                // Game over - find the winner
                const winnerIndex = isActive.findIndex(active => active);
                if (winnerIndex !== -1) {
                  scores[winnerIndex]++;
                  updateScoreboard();
                  gameOverText.innerText = `Player ${winnerIndex + 1} Wins!`;
                  endGame(`p${winnerIndex + 1}`);
                } else {
                  // No winner (shouldn't happen)
                  gameOverText.innerText = "Game Over - No Winner";
                  endGame(null);
                }
              } else {
                // Update scoreboard to show eliminated players
                updateScoreboard();
              }
            }
          }
        });
        
        // Clean up old trail segments based on trail duration setting
        for (let i = trailSegments.length - 1; i >= 0; i--) {
          const seg = trailSegments[i];
          if (now - seg.userData.birth > trailDuration) {
            scene.remove(seg);
            trailSegments.splice(i, 1);
          }
        }
      }
      
      // Render each viewport
      renderer.setScissorTest(true);
      layouts[players.length].forEach((vp, idx) => {
        const Cx = innerWidth * vp.x;
        const Cy = innerHeight * (1 - vp.y - vp.h);
        const Cw = innerWidth * vp.w;
        const Ch = innerHeight * vp.h;
        renderer.setViewport(Cx, Cy, Cw, Ch);
        renderer.setScissor(Cx, Cy, Cw, Ch);
        renderer.render(scene, cameras[idx]);
      });
      renderer.setScissorTest(false);
    }

    // Create dynamic player settings UI
    function createPlayerSettingsUI() {
      const playerColors = document.getElementById('playerColors');
      const playerSettings = document.getElementById('playerSettings');
      
      players.forEach((player, index) => {
        // Color picker
        const colorDiv = document.createElement('div');
        colorDiv.className = 'player-color';
        colorDiv.innerHTML = `
          <label>Player ${index + 1} Color:</label>
          <input type="color" id="p${index+1}ColorPicker" value="#${defaultColors[index].toString(16).padStart(6, '0')}">
        `;
        playerColors.appendChild(colorDiv);
        
        // Speed and jump height controls
        const settingsDiv = document.createElement('div');
        settingsDiv.className = 'player-settings';
        settingsDiv.innerHTML = `
          <h3>Player ${index + 1}</h3>
          <div class="player-speed">
            <label>Speed:</label>
            <input type="range" id="p${index+1}SpeedSlider" min="0.1" max="5" step="0.1" value="0.7">
            <span id="p${index+1}SpeedValue">0.7</span>
          </div>
          <div class="player-jump">
            <label>Jump Height:</label>
            <input type="range" id="p${index+1}JumpHeightSlider" min="0.1" max="20" step="0.1" value="2">
            <span id="p${index+1}JumpHeightValue">2</span>
          </div>
        `;
        playerSettings.appendChild(settingsDiv);
        
        // Add event listeners
        const colorPicker = document.getElementById(`p${index+1}ColorPicker`);
        const speedSlider = document.getElementById(`p${index+1}SpeedSlider`);
        const jumpHeightSlider = document.getElementById(`p${index+1}JumpHeightSlider`);
        
        colorPicker.oninput = () => {
          const color = parseInt(colorPicker.value.slice(1), 16);
          cycles[index].traverse(c => {
        if (c.isMesh) {
              c.material.color.set(colorPicker.value);
              if (c.material.emissive) c.material.emissive.set(colorPicker.value);
        }
      });
    };
        
        speedSlider.oninput = () => {
          speeds[index] = parseFloat(speedSlider.value);
          document.getElementById(`p${index+1}SpeedValue`).textContent = speedSlider.value;
        };
        
        jumpHeightSlider.oninput = () => {
          jumpHeights[index] = parseFloat(jumpHeightSlider.value);
          document.getElementById(`p${index+1}JumpHeightValue`).textContent = jumpHeightSlider.value;
        };
      });
      
      // Add trail duration control
      const trailSettingsDiv = document.createElement('div');
      trailSettingsDiv.className = 'trail-settings';
      trailSettingsDiv.innerHTML = `
        <h3>Trail Settings</h3>
        <div class="trail-duration">
          <label>Trail Duration (seconds):</label>
          <input type="range" id="trailDurationSlider" min="1" max="30" step="1" value="${trailDuration/1000}">
          <span id="trailDurationValue">${trailDuration/1000}</span>
        </div>
      `;
      playerSettings.appendChild(trailSettingsDiv);
      
      // Add event listener for trail duration
      const trailDurationSlider = document.getElementById('trailDurationSlider');
      trailDurationSlider.oninput = () => {
        const seconds = parseInt(trailDurationSlider.value);
        trailDuration = seconds * 1000;
        document.getElementById('trailDurationValue').textContent = seconds;
      };
    }

    // Initialize settings UI
    createPlayerSettingsUI();

    // Settings menu visibility
    document.getElementById('settingsGear').onclick = () => {
      const menu = document.getElementById('settingsMenu');
      menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    };

    // Save settings
    document.getElementById('saveSettingsBtn').onclick = () => {
      document.getElementById('settingsMenu').style.display = 'none';
    };

    // Start game
    document.getElementById('startBtn').onclick = () => {
      document.getElementById('startOverlay').style.display = 'none';
      gameState = 'running';
    };

    // Game over
    function endGame(winner) {
      gameOver = true;
      gameState = 'gameover';
      document.getElementById('gameOverOverlay').style.display = 'flex';
      
      if (winner) {
        const winnerIndex = parseInt(winner.replace('p', '')) - 1;
        scores[winnerIndex]++;
        updateScoreboard();
        document.getElementById('gameOverText').innerText = `Player ${winnerIndex + 1} Wins!`;
      } else {
        document.getElementById('gameOverText').innerText = "Game Over - No Winner";
      }
    }

    // Retry
    document.getElementById('retryBtn').onclick = () => {
      window.location.reload();
    };

    // Pause/Resume
    document.getElementById('pauseBtn').onclick = () => {
      if (gameState === 'running') {
        gameState = 'paused';
      }
    };

    document.getElementById('resumeBtn').onclick = () => {
      if (gameState === 'paused') {
        gameState = 'running';
      }
    };

    // Restart
    document.getElementById('restartBtn').onclick = () => {
      window.location.reload();
    };

    // Exit
    document.getElementById('exitBtn').onclick = () => {
      window.location.href = 'playerSetup.html';
    };

    // Obstacle color picker
    document.getElementById('obsColorPicker').oninput = () => {
      obsColor = parseInt(document.getElementById('obsColorPicker').value.slice(1), 16);
      obstacles.forEach(o => o.material.color.set(document.getElementById('obsColorPicker').value));
    };

    // Arena size slider
    document.getElementById('arenaSizeSlider').oninput = () => {
      BOX = parseInt(document.getElementById('arenaSizeSlider').value);
      half = BOX / 2;
      document.getElementById('arenaSizeValue').textContent = BOX;
      
      // Update boundary
      boundary.geometry.dispose();
      boundary.geometry = new THREE.BoxGeometry(BOX, BOX, BOX);
      boundary.position.set(0, half - 0.5, 0);
      
      // Update grid helper
      scene.remove(gridHelper);
      gridHelper.geometry.dispose();
      gridHelper = new THREE.GridHelper(BOX, BOX / 10, 0x00ffff, 0x222222);
      scene.add(gridHelper);
      
      // Regenerate obstacles
      generateObstacles();
    };

    // Camera zoom slider
    document.getElementById('cameraZoomSlider').oninput = () => {
      camDistance = parseFloat(document.getElementById('cameraZoomSlider').value);
      document.getElementById('cameraZoomValue').textContent = camDistance;
    };

    // Obstacle density
    document.getElementById('levelSelect').onchange = () => {
      obstaclePercent = parseInt(document.getElementById('levelSelect').value);
      generateObstacles();
    };

    // Background selection
    const bgSelect = document.getElementById('bgSelect');
    const bgFiles = [];
    for (let i = 1; i <= 23; i++) {
      bgFiles.push(`bg_ (${i}).jpeg`, `bg_ (${i}).jpg`);
    }
    bgFiles.forEach(fn => {
      const opt = document.createElement('option');
      opt.value = fn;
      opt.textContent = fn;
      bgSelect.appendChild(opt);
    });
    bgSelect.onchange = () => {
      const val = bgSelect.value;
      if (val === 'none') {
        document.body.style.backgroundImage = 'none';
      } else {
        document.body.style.backgroundImage = `url("assets/${val}")`;
      }
    };

    // Initialize game state
    gameState = 'start';
    document.getElementById('startOverlay').style.display = 'flex';
    document.getElementById('gameOverOverlay').style.display = 'none';
    document.getElementById('settingsMenu').style.display = 'none';

    // Check if all players are keyboard players - auto-start if so
    const allKeyboard = players.every(p => p.type === 'keyboard');
    if (allKeyboard) {
      document.getElementById('startBtn').onclick();
    }

    // Initialize scoreboard
    updateScoreboard();

    // Start animation
    animate();

    // Update CSS for keybindings modal
    const style = document.createElement('style');
    style.textContent = `
      #keyBindingsOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      }
      
      #keyBindingsModal {
        background: #111;
        border: 2px solid #0ff;
        border-radius: 10px;
        padding: 20px;
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        color: #0ff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        position: relative;
        z-index: 10001;
      }
      
      #settingsMenu {
        z-index: 9999;
      }
      
      #keyBindingsModal h2 {
        text-align: center;
        margin-top: 0;
        color: #0ff;
        text-shadow: 0 0 10px #0ff;
      }
      
      .player-keybindings {
        margin-bottom: 20px;
        padding: 10px;
        border: 1px solid #0ff;
        border-radius: 5px;
      }
      
      .player-keybindings h3 {
        margin-top: 0;
        color: #0ff;
      }
      
      .keybinding-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 10px 0;
      }
      
      .key-button {
        background: rgba(0, 255, 255, 0.2);
        border: 1px solid #0ff;
        color: #0ff;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        min-width: 100px;
        text-align: center;
      }
      
      .key-button:hover {
        background: rgba(0, 255, 255, 0.3);
      }
      
      .key-button.waiting-for-key {
        background: rgba(255, 255, 0, 0.3);
        border-color: #ff0;
        color: #ff0;
        animation: pulse 1s infinite;
      }
      
      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }
      
      #keyBindingsModal button {
        background: rgba(0, 255, 255, 0.2);
        border: 1px solid #0ff;
        color: #0ff;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        margin: 10px 5px;
      }
      
      #keyBindingsModal button:hover {
        background: rgba(0, 255, 255, 0.3);
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>