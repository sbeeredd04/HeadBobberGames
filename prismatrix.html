<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Prismatrix with Collisions & Obstacles</title>
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&family=Share+Tech+Mono&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      background-color: #000;
    }

    body[style*="background-image"] {
      background-size: cover !important;
      background-position: center center !important;
      background-repeat: no-repeat !important;
      background-attachment: fixed !important;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #gameTitle, #scoreBoard, #startOverlay, #gameOverOverlay, #settingsGear, #settingsMenu, #keyBindingsOverlay {
      position: fixed;
      z-index: 2;
    }

    .viewport-container {
      position: relative;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="gameTitle">Prismatrix</div>
  <div id="scoreBoard"></div>
  <div id="startOverlay">
    <h1 style="font-size:64px;margin:0;">Prismatrix</h1>
    <button id="startBtn">Start Game</button>
  </div>
  <div id="gameOverOverlay">
    <h1 id="gameOverText"></h1>
    <button id="retryBtn">Retry</button>
  </div>
  <!-- Key Bindings Modal -->
  <div id="keyBindingsOverlay">
    <div id="keyBindingsModal">
      <h2>Key Bindings</h2>
      <div id="keyBindingsList"></div>
      <div class="modal-buttons">
        <button id="saveKeyBindingsBtn">Save Changes</button>
        <button id="resetDefaultsBtn">Reset to Defaults</button>
        <button id="cancelKeyBindingsBtn">Cancel</button>
      </div>
    </div>
  </div>
  <div id="settingsGear">⚙</div>
  <div id="settingsMenu">
    <fieldset><legend>Appearance</legend>
      <div id="playerColors"></div>
      <label>Obstacle Color: <input type="color" id="obsColorPicker" value="#ffff00"></label>
      <label>Background: <select id="bgSelect">
        <option value="none">None</option>
      </select></label>
    </fieldset>
    <fieldset><legend>Gameplay</legend>
      <div id="playerSettings"></div>
    </fieldset>
    <fieldset><legend>Arena & Camera</legend>
      <label>Arena Size: <input type="range" id="arenaSizeSlider" min="600" max="5000" step="100" value="800"><span id="arenaSizeValue">800</span></label>
      <label>Camera Zoom: <input type="range" id="cameraZoomSlider" min="20" max="100" step="5" value="50"><span id="cameraZoomValue">50</span></label>
    </fieldset>
    <fieldset><legend>Difficulty</legend>
      <label>Obstacle Density: <select id="levelSelect">
        <option value="5">Very Easy (5%)</option>
        <option value="10">Easy (10%)</option>
        <option value="15" selected>Medium (15%)</option>
        <option value="20">Hard (20%)</option>
        <option value="25">Insane (25%)</option>
      </select></label>
    </fieldset>
    <fieldset><legend>Actions</legend>
      <button id="saveSettingsBtn">Save Settings</button>
      <button id="exitBtn">Exit Game</button>
      <button id="keyBindingsBtn">Key Bindings</button>
      <button id="pauseBtn">Pause</button>
      <button id="resumeBtn">Resume</button>
      <button id="restartBtn">Reset</button>
    </fieldset>
  </div>
  <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
  <script>
    // ─── Setup & State ─────────────────────────────────────
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor(0x000000, 0);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Game state variables
    let gameState = 'start'; // 'start', 'running', 'paused', 'gameover'
    let gameOver = false;
    let turnSpeed = 0.03; // Reduced for better control
    let camDistance = 50; // Increased default camera distance
    const jumpDuration = 500;
    let obsColor = 0xffff00; // Default obstacle color
    let trailDuration = 5000; // Default trail duration in milliseconds
    let activePlayers = []; // Track which players are still active

    // Arrays for game objects and state
    const cameras = [];
    const cycles = [];
    const turns = [];
    const jumps = [];
    const camHeights = [];
    const speeds = [];
    const jumpHeights = [];
    const scores = [];
    const channels = [];
    const isActive = []; // Track if each player is still active
    const trailSegments = [];
    const obstacles = [];

    const defaultColors = [0x00ff00, 0xff0000, 0x0000ff, 0xffff00, 0xff00ff];

    // Starting positions for players
    const spawnPoints = [
      {x: -100, z: 0, rotation: 0}, // P1 - Left, facing right
      {x: 100, z: 0, rotation: Math.PI}, // P2 - Right, facing left
      {x: 0, z: -100, rotation: Math.PI/2}, // P3 - Top, facing down
      {x: -70, z: 70, rotation: -Math.PI/4}, // P4 - Top-left, facing bottom-right
      {x: 70, z: 70, rotation: -3*Math.PI/4} // P5 - Top-right, facing bottom-left
    ];

    // Define viewport layouts
    let viewportLayouts = {
      2: [
        {x: 0, y: 0, w: 0.5, h: 1},    // Left half
        {x: 0.5, y: 0, w: 0.5, h: 1}   // Right half
      ],
      3: [
        {x: 0, y: 0, w: 0.5, h: 0.5},      // Top left
        {x: 0.5, y: 0, w: 0.5, h: 0.5},    // Top right
        {x: 0.25, y: 0.5, w: 0.5, h: 0.5}  // Bottom center
      ],
      4: [
        {x: 0, y: 0, w: 0.5, h: 0.5},      // Top left
        {x: 0.5, y: 0, w: 0.5, h: 0.5},    // Top right
        {x: 0, y: 0.5, w: 0.5, h: 0.5},    // Bottom left
        {x: 0.5, y: 0.5, w: 0.5, h: 0.5}   // Bottom right
      ],
      5: [
        {x: 0, y: 0, w: 0.33, h: 0.5},     // Top left
        {x: 0.33, y: 0, w: 0.34, h: 0.5},  // Top center
        {x: 0.67, y: 0, w: 0.33, h: 0.5},  // Top right
        {x: 0.165, y: 0.5, w: 0.33, h: 0.5}, // Bottom left
        {x: 0.505, y: 0.5, w: 0.33, h: 0.5}  // Bottom right
      ]
    };

    // Function to update camera viewports
    function updateCameraViewports() {
      const layout = viewportLayouts[players.length];
      layout.forEach((vp, idx) => {
        if (cameras[idx]) {  // Check if camera exists
          const vpWidth = innerWidth * vp.w;
          const vpHeight = innerHeight * vp.h;
          cameras[idx].aspect = vpWidth / vpHeight;
          cameras[idx].updateProjectionMatrix();
        }
      });
    }

    // Window resize handler
    window.addEventListener('resize', () => {
      renderer.setSize(innerWidth, innerHeight);
      updateCameraViewports();
    });

    // Load players from localStorage
    const players = JSON.parse(localStorage.getItem('prismatrixPlayers')) || [];
    if (players.length < 2 || players.length > 5) {
      window.location.href = 'playerSetup.html';
    }

    // Default keybindings for each player
    const playerDefaultKeybindings = [
      { // P1
        left: 'KeyA',
        right: 'KeyD',
        jump: 'KeyW',
        camUp: 'KeyQ',
        camDown: 'KeyE'
      },
      { // P2
        left: 'ArrowLeft',
        right: 'ArrowRight',
        jump: 'ArrowUp',
        camUp: 'Slash',
        camDown: 'Period'
      },
      { // P3
        left: 'KeyJ',
        right: 'KeyL',
        jump: 'KeyI',
        camUp: 'KeyU',
        camDown: 'KeyO'
      },
      { // P4
        left: 'KeyF',
        right: 'KeyH',
        jump: 'KeyT',
        camUp: 'KeyR',
        camDown: 'KeyY'
      },
      { // P5
        left: 'Numpad4',
        right: 'Numpad6',
        jump: 'Numpad5',
        camUp: 'Numpad7',
        camDown: 'Numpad9'
      }
    ];

    // Ensure each player has correct keybindings
    players.forEach((player, index) => {
      if (player.type === 'keyboard') {
        player.keymap = { ...playerDefaultKeybindings[index] };
      }
    });

    // Save players to localStorage
    localStorage.setItem('prismatrixPlayers', JSON.stringify(players));

    // Default game settings
    const DEFAULT_SETTINGS = {
      speed: 0.7,        // Default slower speed
      minSpeed: 0.4,     // Minimum speed
      maxSpeed: 2.0,     // Maximum speed
      jumpHeight: 3,     // Default jump height
      minJumpHeight: 2,  // Minimum jump height
      maxJumpHeight: 20, // Maximum jump height
      camHeight: 30,     // Default camera height
      minCamHeight: 10,  // Minimum camera height
      maxCamHeight: 200  // Maximum camera height
    };

    // Initialize players, cameras, and cycles
    players.forEach((player, index) => {
      // Initialize camera
      const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
      cameras.push(camera);
      
      // Create cycle
      const cycle = makeCycle(defaultColors[index]);
      cycle.position.set(spawnPoints[index].x, 0.8, spawnPoints[index].z);
      cycle.rotation.y = spawnPoints[index].rotation;
      cycles.push(cycle);
      
      // Initialize state arrays with default values
      turns.push(0);
      jumps.push(0);
      camHeights.push(DEFAULT_SETTINGS.camHeight);
      speeds.push(DEFAULT_SETTINGS.speed);
      jumpHeights.push(DEFAULT_SETTINGS.jumpHeight);
      scores.push(0);
      isActive.push(true);
      
      if (player.type === 'phone') {
        const channel = new BroadcastChannel(`prismatrix-${player.id}`);
        channel.onmessage = e => handleMobileInput(index, e.data);
        channels.push(channel);
      }
    });

    // Initial viewport setup
    updateCameraViewports();

    // Render viewports function
    function renderViewports() {
      renderer.setScissorTest(true);
      viewportLayouts[players.length].forEach((vp, idx) => {
        const vpX = innerWidth * vp.x;
        const vpY = innerHeight * (1 - vp.y - vp.h);
        const vpWidth = innerWidth * vp.w;
        const vpHeight = innerHeight * vp.h;

        renderer.setViewport(vpX, vpY, vpWidth, vpHeight);
        renderer.setScissor(vpX, vpY, vpWidth, vpHeight);

        const camera = cameras[idx];
        camera.aspect = vpWidth / vpHeight;
        camera.updateProjectionMatrix();

        renderer.render(scene, camera);
      });
      renderer.setScissorTest(false);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      if (gameState === 'running' && !gameOver) {
        const now = Date.now();
        
        // Update each player
        players.forEach((player, index) => {
          if (!isActive[index]) return;
          
          const cycle = cycles[index];
          const jumping = now - jumps[index] < jumpDuration;
          
          // Update position and rotation
          cycle.position.y = jumping ? 
            0.8 + jumpHeights[index] * Math.sin(Math.PI * (now - jumps[index])/jumpDuration) : 
            0.8;
          
          cycle.rotation.y += turns[index] * turnSpeed;
          cycle.rotation.z = turns[index] * Math.PI / 8;
          
          // Movement and trail
          const forward = new THREE.Vector3(0, 0, -1)
            .applyQuaternion(cycle.quaternion)
            .multiplyScalar(speeds[index]);
          const oldPos = cycle.position.clone();
          cycle.position.add(forward);
          
          makeSegment(oldPos, cycle.position, defaultColors[index], `p${index+1}`);
          
          // Camera follow
          const behind = forward.clone().normalize().multiplyScalar(-camDistance);
          const camPos = cycle.position.clone()
            .add(behind)
            .setY(cycle.position.y + camHeights[index]);
          cameras[index].position.lerp(camPos, 0.1);
          cameras[index].lookAt(cycle.position);
          
          // Collision detection
          if (!jumping) {
            const collisionResult = detectCollision(cycle, `p${index+1}`);
            if (collisionResult.collision) handleCollision(index, collisionResult);
          }
        });
        
        // Clean up old trail segments
        cleanupTrails(now);
      }
      
      // Render viewports
      renderViewports();
    }

    // Start animation
    animate();

    // Handle collision function
    function handleCollision(playerIndex, collisionResult) {
      isActive[playerIndex] = false;
      createExplosion(collisionResult.point, defaultColors[playerIndex]);
      
      if (players[playerIndex].type === 'phone') {
        notifyController(playerIndex, {
          type: 'playerEliminated',
          playerId: playerIndex + 1,
          collisionType: collisionResult.type,
          otherPlayer: collisionResult.otherPlayer
        });
      }
      
      const activeCount = isActive.filter(active => active).length;
      if (activeCount <= 1) {
        const winnerIndex = isActive.findIndex(active => active);
        if (winnerIndex !== -1) {
          scores[winnerIndex]++;
          updateScoreboard();
          gameOverText.innerText = `Player ${winnerIndex + 1} Wins!`;
          endGame(`p${winnerIndex + 1}`);
        } else {
          gameOverText.innerText = "Game Over - No Winner";
          endGame(null);
        }
      } else {
        updateScoreboard();
      }
    }

    // Clean up trails function
    function cleanupTrails(now) {
      for (let i = trailSegments.length - 1; i >= 0; i--) {
        const seg = trailSegments[i];
        if (now - seg.userData.birth > trailDuration) {
          scene.remove(seg);
          trailSegments.splice(i, 1);
        }
      }
    }

    // Update layouts object to maintain aspect ratios better
    viewportLayouts = {
      2: [
        {x: 0, y: 0, w: 0.5, h: 1},    // Left half
        {x: 0.5, y: 0, w: 0.5, h: 1}   // Right half
      ],
      3: [
        {x: 0, y: 0, w: 0.5, h: 0.5},      // Top left
        {x: 0.5, y: 0, w: 0.5, h: 0.5},    // Top right
        {x: 0.25, y: 0.5, w: 0.5, h: 0.5}  // Bottom center
      ],
      4: [
        {x: 0, y: 0, w: 0.5, h: 0.5},      // Top left
        {x: 0.5, y: 0, w: 0.5, h: 0.5},    // Top right
        {x: 0, y: 0.5, w: 0.5, h: 0.5},    // Bottom left
        {x: 0.5, y: 0.5, w: 0.5, h: 0.5}   // Bottom right
      ],
      5: [
        {x: 0, y: 0, w: 0.33, h: 0.5},     // Top left
        {x: 0.33, y: 0, w: 0.34, h: 0.5},  // Top center
        {x: 0.67, y: 0, w: 0.33, h: 0.5},  // Top right
        {x: 0.165, y: 0.5, w: 0.33, h: 0.5}, // Bottom left
        {x: 0.505, y: 0.5, w: 0.33, h: 0.5}  // Bottom right
      ]
    };

    // Update scoreboard
    function updateScoreboard() {
      const scoreText = players.map((p, i) => `P${i+1}: ${scores[i]}${!isActive[i] ? ' (Eliminated)' : ''}`).join(' | ');
      document.getElementById('scoreBoard').textContent = scoreText;
    }

    // Handle mobile input
    function handleMobileInput(playerIndex, data) {
      switch(data.action) {
        case 'move':
          turns[playerIndex] = Math.sign(data.value);
          break;
        case 'jump':
          if (Date.now() - jumps[playerIndex] > jumpDuration) {
            jumps[playerIndex] = Date.now();
          }
          break;
        case 'camUp':
          camHeights[playerIndex] = Math.min(camHeights[playerIndex] + 2, DEFAULT_SETTINGS.maxCamHeight);
          break;
        case 'camDown':
          camHeights[playerIndex] = Math.max(camHeights[playerIndex] - 2, DEFAULT_SETTINGS.minCamHeight);
          break;
        case 'left':
          turns[playerIndex] = 1;
          break;
        case 'right':
          turns[playerIndex] = -1;
          break;
      }
    }

    // Keybindings UI
    document.getElementById('keyBindingsBtn').onclick = () => {
      showKeybindingsModal();
    };

    document.getElementById('cancelKeyBindingsBtn').onclick = () => {
      hideKeybindingsModal();
    };

    document.getElementById('saveKeyBindingsBtn').onclick = () => {
      saveKeybindings();
      hideKeybindingsModal();
    };

    function showKeybindingsModal() {
      const keyBindingsList = document.getElementById('keyBindingsList');
      keyBindingsList.innerHTML = '';
      
      // Create keybinding UI for each keyboard player
      players.forEach((player, index) => {
        if (player.type !== 'keyboard') return;
        
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-keybindings';
        playerDiv.innerHTML = `
          <h3>Player ${index + 1} Controls</h3>
          <div class="keybinding-row">
            <span>Turn Left</span>
            <button class="key-button" data-player="${index}" data-action="left">${player.keymap.left}</button>
          </div>
          <div class="keybinding-row">
            <span>Turn Right</span>
            <button class="key-button" data-player="${index}" data-action="right">${player.keymap.right}</button>
          </div>
          <div class="keybinding-row">
            <span>Jump</span>
            <button class="key-button" data-player="${index}" data-action="jump">${player.keymap.jump}</button>
          </div>
          <div class="keybinding-row">
            <span>Camera Up</span>
            <button class="key-button" data-player="${index}" data-action="camUp">${player.keymap.camUp}</button>
          </div>
          <div class="keybinding-row">
            <span>Camera Down</span>
            <button class="key-button" data-player="${index}" data-action="camDown">${player.keymap.camDown}</button>
          </div>
        `;
        keyBindingsList.appendChild(playerDiv);
      });

      // Add modal buttons
      const buttonsDiv = document.createElement('div');
      buttonsDiv.className = 'modal-buttons';
      buttonsDiv.innerHTML = `
        <button id="saveKeyBindingsBtn">Save Changes</button>
        <button id="resetDefaultsBtn">Reset to Defaults</button>
        <button id="cancelKeyBindingsBtn">Cancel</button>
      `;
      keyBindingsList.appendChild(buttonsDiv);
      
      // Add event listeners
      addKeyBindingListeners();
      
      // Show the modal
      document.getElementById('keyBindingsOverlay').style.display = 'flex';
    }

    function addKeyBindingListeners() {
      // Add event listeners to key buttons
      document.querySelectorAll('.key-button').forEach(button => {
        button.addEventListener('click', () => {
          // Remove waiting state from any other buttons
          document.querySelectorAll('.key-button').forEach(btn => {
            btn.classList.remove('waiting-for-key');
            btn.dataset.waiting = 'false';
          });
          
          // Highlight the button to show it's waiting for input
          button.classList.add('waiting-for-key');
          button.textContent = 'PRESS ANY KEY';
          button.dataset.waiting = 'true';
        });
      });

      // Add event listeners for modal buttons
      document.getElementById('saveKeyBindingsBtn').addEventListener('click', () => {
        saveKeybindings();
        hideKeybindingsModal();
      });

      document.getElementById('resetDefaultsBtn').addEventListener('click', () => {
        players.forEach((player, index) => {
          if (player.type === 'keyboard') {
            player.keymap = { ...playerDefaultKeybindings[index] };
          }
        });
        showKeybindingsModal(); // Refresh the modal
      });

      document.getElementById('cancelKeyBindingsBtn').addEventListener('click', hideKeybindingsModal);
    }

    function hideKeybindingsModal() {
      document.getElementById('keyBindingsOverlay').style.display = 'none';
      
      // Remove any waiting-for-key state
      document.querySelectorAll('.key-button').forEach(button => {
        button.classList.remove('waiting-for-key');
        button.dataset.waiting = 'false';
      });
    }

    function saveKeybindings() {
      // Save the current keybindings to localStorage
      localStorage.setItem('prismatrixPlayers', JSON.stringify(players));
    }

    // Add a global keydown event listener for keybinding changes
    window.addEventListener('keydown', e => {
      // Check if we're waiting for a key for keybinding
      const waitingButton = document.querySelector('.key-button[data-waiting="true"]');
      if (waitingButton) {
        e.preventDefault();
        
        // Get the player and action from the button
        const playerIndex = parseInt(waitingButton.dataset.player);
        const action = waitingButton.dataset.action;
        
        // Update the keybinding
        players[playerIndex].keymap[action] = e.code;
        
        // Update the button text
        waitingButton.textContent = e.code;
        
        // Remove the waiting state
        waitingButton.classList.remove('waiting-for-key');
        waitingButton.dataset.waiting = 'false';
        
        return;
      }
      
      // Check if this is a start game key press
      if (gameState === 'start' && e.code === 'Enter') {
        document.getElementById('startBtn').onclick();
        return;
      }
      
      // Check if this is a pause/resume key press
      if ((gameState === 'running' || gameState === 'paused') && e.code === 'Space') {
        if (gameState === 'running') {
          document.getElementById('pauseBtn').onclick();
        } else if (gameState === 'paused') {
          document.getElementById('resumeBtn').onclick();
        }
        return;
      }
      
      // Only process game controls if game is running
      if (gameState !== 'running') return;
      
      players.forEach((player, index) => {
        if (player.type !== 'keyboard') return;
        
        // Check if the pressed key matches any of the player's keybindings
        if (e.code === player.keymap.left) turns[index] = 1;
        else if (e.code === player.keymap.right) turns[index] = -1;
        else if (e.code === player.keymap.jump && Date.now() - jumps[index] > jumpDuration) {
          jumps[index] = Date.now();
        }
        else if (e.code === player.keymap.camUp) camHeights[index] = Math.min(camHeights[index] + 2, DEFAULT_SETTINGS.maxCamHeight);
        else if (e.code === player.keymap.camDown) camHeights[index] = Math.max(camHeights[index] - 2, DEFAULT_SETTINGS.minCamHeight);
      });
    });

    window.addEventListener('keyup', e => {
      if (gameState !== 'running') return;
      
      players.forEach((player, index) => {
        if (player.type !== 'keyboard') return;
        if (e.code === player.keymap.left && turns[index] > 0) turns[index] = 0;
        else if (e.code === player.keymap.right && turns[index] < 0) turns[index] = 0;
      });
    });

    // ─── Lighting ──────────────────────────────────────────
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 20, 7.5);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0x404040));

    // ─── Arena ─────────────────────────────────────────────
    let BOX = 800; // Default arena size
    let half = BOX / 2;
    const boxGeo = new THREE.BoxGeometry(BOX, BOX, BOX);
    const boxMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true });
    const boundary = new THREE.Mesh(boxGeo, boxMat);
    boundary.position.set(0, half - 0.5, 0);
    scene.add(boundary);
    let gridHelper = new THREE.GridHelper(BOX, BOX / 10, 0x00ffff, 0x222222);
    scene.add(gridHelper);

    // ─── Light‑cycle factory ─────────────────────────────
    function makeCycle(color) {
      const group = new THREE.Group();
      
      // Create collision meshes (invisible)
      const collisionBody = new THREE.Mesh(
        new THREE.BoxGeometry(1, 4.0, 2), // Increased length and width
        new THREE.MeshBasicMaterial({ visible: false })
      );
      collisionBody.name = 'collisionBody';
      group.add(collisionBody);

      const collisionHead = new THREE.Mesh(
        new THREE.BoxGeometry(1.6, 4.0, 1.2),
        new THREE.MeshBasicMaterial({ visible: false })
      );
      collisionHead.position.set(0, 0, -2.5);
      collisionHead.name = 'collisionHead';
      group.add(collisionHead);

      // Main body - glossy black frame with enhanced neon
      const bodyGeo = new THREE.BoxGeometry(1.6, 4.0, 5.5);
      const bodyMat = new THREE.MeshPhysicalMaterial({ 
        color: 0x000000,
        metalness: 1.0,
        roughness: 0.05,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05,
        reflectivity: 1.0,
        name: 'bodyMaterial'
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 2.0;
      body.name = 'visualBody';
      group.add(body);

      // Wheels - layered design with multiple rings
      const wheelRadius = 2.0;
      const wheelThickness = 0.4; // Increased thickness

      const wheelMat = new THREE.MeshPhysicalMaterial({
        color: 0x000000,
        metalness: 1.0,
        roughness: 0.05,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05,
        reflectivity: 1.0,
        name: 'wheelMaterial'
      });

      // Create layered wheel function
      function createLayeredWheel(position) {
        const wheelGroup = new THREE.Group();
        
        // Outer black wheel
        const outerWheelGeo = new THREE.TorusGeometry(wheelRadius, wheelThickness, 32, 48);
        const outerWheel = new THREE.Mesh(outerWheelGeo, wheelMat);
        wheelGroup.add(outerWheel);

        // Middle wheel (colored)
        const middleWheelGeo = new THREE.TorusGeometry(wheelRadius * 0.9, wheelThickness * 1.2, 32, 48);
        const middleWheel = new THREE.Mesh(middleWheelGeo, new THREE.MeshPhysicalMaterial({
          color: color,
          metalness: 0.9,
          roughness: 0.1,
          emissive: color,
          emissiveIntensity: 0.5,
          name: 'neonMaterial'
        }));
        wheelGroup.add(middleWheel);

        // Inner black wheel
        const innerWheelGeo = new THREE.TorusGeometry(wheelRadius * 0.8, wheelThickness, 32, 48);
        const innerWheel = new THREE.Mesh(innerWheelGeo, wheelMat);
        wheelGroup.add(innerWheel);

        // Neon rings
        [1.05, 0.95, 0.85, 0.75].forEach(scale => {
          const ringGeo = new THREE.TorusGeometry(wheelRadius * scale, 0.08, 16, 48);
          const ring = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 1.5,
            transparent: true,
            opacity: 0.9,
            name: 'neonMaterial'
          }));
          wheelGroup.add(ring);
        });

        wheelGroup.rotation.y = Math.PI / 2;
        wheelGroup.position.copy(position);
        return wheelGroup;
      }

      // Add front and back wheels - increased spacing
      group.add(createLayeredWheel(new THREE.Vector3(0, 2.0, -2.5)));
      group.add(createLayeredWheel(new THREE.Vector3(0, 2.0, 2.5)));

      // Enhanced body neon effects - multiple layers
      const glowMat = new THREE.MeshBasicMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 1.5,
        transparent: true,
        opacity: 0.9,
        name: 'neonMaterial'
      });

      // Body neon strips - multiple layers on sides
      [-0.75, -0.6, -0.45, 0.45, 0.6, 0.75].forEach((x, i) => {
        const strip = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 3.8, 0.08),
          glowMat
        );
        strip.position.set(x, 2.0, 0);
        group.add(strip);

        // Horizontal connectors
        if (i < 3) {
          const connector = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.08, 5.2),
            glowMat
          );
          connector.position.set(x + 0.15, 2.0 + (i - 1), 0);
          group.add(connector);
        }
      });

      // Top light strips
      [-2.5, 0, 2.5].forEach(z => {
        const topStrip = new THREE.Mesh(
          new THREE.BoxGeometry(1.6, 0.08, 0.08),
          glowMat
        );
        topStrip.position.set(0, 4.0, z);
        group.add(topStrip);
      });

      // Enhanced glow effects
      [-2.5, 0, 2.5].forEach(z => {
        const light = new THREE.PointLight(color, 1.2, 4.0);
        light.position.set(0, 2.0, z);
        group.add(light);

        // Volumetric glow
        const glowSphere = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 16, 16),
          new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.2
          })
        );
        glowSphere.position.copy(light.position);
        group.add(glowSphere);
      });

      group.position.y = 2.0;
      scene.add(group);
      return group;
    }

    // Enhanced trail segment creation
    function makeSegment(start, end, color, owner) {
      const length = start.distanceTo(end);
      const trailHeight = 4.0; // Match wheel height
      
      // Create main trail body - more translucent
      const trailMat = new THREE.MeshPhysicalMaterial({
        color: color,
        transparent: true,
        opacity: 0.15, // Much more transparent
        metalness: 0.9,
        roughness: 0.2,
        emissive: color,
        emissiveIntensity: 0.2
      });

      // Create edge material - fully opaque with strong glow
      const edgeMat = new THREE.MeshBasicMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 1.5,
        transparent: true,
        opacity: 0.9
      });

      // Main trail body - taller and thinner
      const mainTrail = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, trailHeight, length), // Thinner main trail
        trailMat
      );

      // Edge strips - fully opaque with increased thickness
      const edgeGeo = new THREE.BoxGeometry(0.03, trailHeight, length); // Thinner edges
      const leftEdge = new THREE.Mesh(edgeGeo, edgeMat);
      const rightEdge = new THREE.Mesh(edgeGeo, edgeMat);
      
      // Position edges closer together
      leftEdge.position.x = -0.075;
      rightEdge.position.x = 0.075;

      // Add horizontal edges at top and bottom
      const horizontalEdgeGeo = new THREE.BoxGeometry(0.15, 0.03, length);
      const topEdge = new THREE.Mesh(horizontalEdgeGeo, edgeMat);
      const bottomEdge = new THREE.Mesh(horizontalEdgeGeo, edgeMat);
      
      topEdge.position.y = trailHeight/2;
      bottomEdge.position.y = -trailHeight/2;

      // Create a group for the trail segment
      const trailGroup = new THREE.Group();
      trailGroup.add(mainTrail);
      trailGroup.add(leftEdge);
      trailGroup.add(rightEdge);
      trailGroup.add(topEdge);
      trailGroup.add(bottomEdge);

      // Position and orient the trail
      trailGroup.position.copy(start).add(end).multiplyScalar(0.5);
      trailGroup.lookAt(end);
      trailGroup.rotateX(Math.PI / 2);

      // Add metadata
      trailGroup.userData.birth = Date.now();
      trailGroup.userData.owner = owner;

      scene.add(trailGroup);
      trailSegments.push(trailGroup);
    }

    // ─── Obstacles ─────────────────────────────────────────
    const obsGeo = new THREE.BoxGeometry(4, 4, 4);
    const obsMat = new THREE.MeshStandardMaterial({ color: obsColor });
    let obstaclePercent = 15; // Default obstacle density

    function generateObstacles() {
      obstacles.forEach(o => scene.remove(o));
      obstacles.length = 0;
      const count = Math.floor(BOX * obstaclePercent / 100);
      for (let i = 0; i < count; i++) {
        const obs = new THREE.Mesh(obsGeo, new THREE.MeshStandardMaterial({ color: obsColor }));
        obs.position.set((Math.random() - 0.5) * (BOX - 20), 2, (Math.random() - 0.5) * (BOX - 20));
        scene.add(obs);
        obstacles.push(obs);
      }
    }
    // initial generate
    generateObstacles();

    // ─── Collision Detection ─────────────────────────────
    function detectCollision(cycle, owner) {
      // Get collision meshes
      const collisionBody = cycle.getObjectByName('collisionBody');
      const collisionHead = cycle.getObjectByName('collisionHead');
      
      // Update world matrices for accurate bounds
      cycle.updateMatrixWorld(true);
      collisionBody.updateMatrixWorld(true);
      collisionHead.updateMatrixWorld(true);
      
      // Create bounding boxes for body and head
      const bodyBox = new THREE.Box3().setFromObject(collisionBody);
      const headBox = new THREE.Box3().setFromObject(collisionHead);
      
      // Get cycle dimensions for precise boundary checking
      const cycleSize = new THREE.Vector3();
      bodyBox.getSize(cycleSize);
      
      // Out of bounds check with precise dimensions
      if (Math.abs(cycle.position.x) > half - cycleSize.x/2 || 
          Math.abs(cycle.position.z) > half - cycleSize.z/2) {
        return {
          collision: true,
          type: 'boundary',
          point: cycle.position.clone()
        };
      }
      
      // Obstacle collision with separate checks for body and head
      for (let obs of obstacles) {
        obs.updateMatrixWorld(true);
        const obsBox = new THREE.Box3().setFromObject(obs);
        
        if (bodyBox.intersectsBox(obsBox) || headBox.intersectsBox(obsBox)) {
          return {
            collision: true,
            type: 'obstacle',
            point: obs.position.clone()
          };
        }
      }
      
      // Trail collision with improved precision and self-trail delay
      const now = Date.now();
      for (let seg of trailSegments) {
        // For own trail, only check collisions after 1 second
        if (seg.userData.owner === owner) {
          if (now - seg.userData.birth < 1000) continue; // Skip if trail is less than 1 second old
        } else {
          // For other players' trails, keep a small delay to prevent immediate collisions
          if (now - seg.userData.birth < 50) continue;
        }
        
        seg.updateMatrixWorld(true);
        const segBox = new THREE.Box3().setFromObject(seg);
        
        // Check both body and head collisions with trails
        if (bodyBox.intersectsBox(segBox) || headBox.intersectsBox(segBox)) {
          return {
            collision: true,
            type: 'trail',
            point: seg.position.clone(),
            owner: seg.userData.owner
          };
        }
      }
      
      // Player-to-player collision detection
      for (let i = 0; i < cycles.length; i++) {
        const otherCycle = cycles[i];
        if (!isActive[i] || otherCycle === cycle) continue;
        
        otherCycle.updateMatrixWorld(true);
        const otherBody = otherCycle.getObjectByName('collisionBody');
        const otherHead = otherCycle.getObjectByName('collisionHead');
        
        if (!otherBody || !otherHead) continue;
        
        const otherBodyBox = new THREE.Box3().setFromObject(otherBody);
        const otherHeadBox = new THREE.Box3().setFromObject(otherHead);
        
        // Check all possible collision combinations
        if (bodyBox.intersectsBox(otherBodyBox) || 
            bodyBox.intersectsBox(otherHeadBox) || 
            headBox.intersectsBox(otherBodyBox) || 
            headBox.intersectsBox(otherHeadBox)) {
          return {
            collision: true,
            type: 'player',
            point: otherCycle.position.clone(),
            otherPlayer: i + 1
          };
        }
      }
      
      return { collision: false };
    }

    // Add explosion effect function
    function createExplosion(position, color) {
      const particleCount = 50;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const velocities = [];
      
      for (let i = 0; i < particleCount; i++) {
        positions.push(
          position.x + (Math.random() - 0.5) * 0.5,
          position.y + (Math.random() - 0.5) * 0.5,
          position.z + (Math.random() - 0.5) * 0.5
        );
        
        velocities.push(
          (Math.random() - 0.5) * 0.2,
          Math.random() * 0.2,
          (Math.random() - 0.5) * 0.2
        );
      }
      
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      
      const material = new THREE.PointsMaterial({
        color: color,
        size: 0.2,
        transparent: true,
        opacity: 1
      });
      
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      // Animate explosion
      const startTime = Date.now();
      const duration = 1000; // 1 second
      
      function animateExplosion() {
        const positions = particles.geometry.attributes.position.array;
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          scene.remove(particles);
          return;
        }
        
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          positions[i3] += velocities[i3] * (1 - progress);
          positions[i3 + 1] += velocities[i3 + 1] * (1 - progress);
          positions[i3 + 2] += velocities[i3 + 2] * (1 - progress);
        }
        
        particles.geometry.attributes.position.needsUpdate = true;
        material.opacity = 1 - progress;
        
        requestAnimationFrame(animateExplosion);
      }
      
      animateExplosion();
    }

    // Create dynamic player settings UI with adjusted ranges
    function createPlayerSettingsUI() {
      const playerColors = document.getElementById('playerColors');
      const playerSettings = document.getElementById('playerSettings');
      
      players.forEach((player, index) => {
        // Color picker
        const colorDiv = document.createElement('div');
        colorDiv.className = 'player-color';
        colorDiv.innerHTML = `
          <label>Player ${index + 1} Color:</label>
          <input type="color" id="p${index+1}ColorPicker" value="#${defaultColors[index].toString(16).padStart(6, '0')}">
        `;
        playerColors.appendChild(colorDiv);
        
        // Speed and jump height controls
        const settingsDiv = document.createElement('div');
        settingsDiv.className = 'player-settings';
        settingsDiv.innerHTML = `
          <h3>Player ${index + 1}</h3>
          <div class="player-speed">
            <label>Speed:</label>
            <input type="range" id="p${index+1}SpeedSlider" 
              min="${DEFAULT_SETTINGS.minSpeed}" 
              max="${DEFAULT_SETTINGS.maxSpeed}" 
              step="0.05" 
              value="${DEFAULT_SETTINGS.speed}">
            <span id="p${index+1}SpeedValue">${DEFAULT_SETTINGS.speed}</span>
          </div>
          <div class="player-jump">
            <label>Jump Height:</label>
            <input type="range" id="p${index+1}JumpHeightSlider"
              min="${DEFAULT_SETTINGS.minJumpHeight}"
              max="${DEFAULT_SETTINGS.maxJumpHeight}"
              step="0.5"
              value="${DEFAULT_SETTINGS.jumpHeight}">
            <span id="p${index+1}JumpHeightValue">${DEFAULT_SETTINGS.jumpHeight}</span>
          </div>
          <div class="player-camera">
            <label>Camera Height:</label>
            <input type="range" id="p${index+1}CamHeightSlider"
              min="${DEFAULT_SETTINGS.minCamHeight}"
              max="${DEFAULT_SETTINGS.maxCamHeight}"
              step="5"
              value="${DEFAULT_SETTINGS.camHeight}">
            <span id="p${index+1}CamHeightValue">${DEFAULT_SETTINGS.camHeight}</span>
          </div>
        `;
        playerSettings.appendChild(settingsDiv);
        
        // Add event listeners
        const colorPicker = document.getElementById(`p${index+1}ColorPicker`);
        const speedSlider = document.getElementById(`p${index+1}SpeedSlider`);
        const jumpHeightSlider = document.getElementById(`p${index+1}JumpHeightSlider`);
        const camHeightSlider = document.getElementById(`p${index+1}CamHeightSlider`);
        
        colorPicker.oninput = () => {
          const color = parseInt(colorPicker.value.slice(1), 16);
          
          // Clear existing trails for this player
          const playerTrails = trailSegments.filter(seg => seg.userData.owner === `p${index+1}`);
          playerTrails.forEach(trail => {
            scene.remove(trail);
            const trailIndex = trailSegments.indexOf(trail);
            if (trailIndex > -1) {
              trailSegments.splice(trailIndex, 1);
            }
          });

          // Update bike colors
          cycles[index].traverse(c => {
            if (c.isMesh && c.material) {
              // Only change materials specifically marked as neon
              if (c.material.name === 'neonMaterial') {
                c.material.color.set(colorPicker.value);
                if (c.material.emissive) {
                  c.material.emissive.set(colorPicker.value);
                }
              }
              // Ensure black materials stay black
              if (c.material.name === 'bodyMaterial' || c.material.name === 'wheelMaterial') {
                c.material.color.setHex(0x000000);
                if (c.material.emissive) {
                  c.material.emissive.setHex(0x000000);
                }
              }
            }
            // Update point lights
            if (c.isPointLight) {
              c.color.set(colorPicker.value);
            }
          });

          // Update default colors array for new trails
          defaultColors[index] = color;
        };
        
        speedSlider.oninput = () => {
          speeds[index] = parseFloat(speedSlider.value);
          document.getElementById(`p${index+1}SpeedValue`).textContent = speedSlider.value;
        };
        
        jumpHeightSlider.oninput = () => {
          jumpHeights[index] = parseFloat(jumpHeightSlider.value);
          document.getElementById(`p${index+1}JumpHeightValue`).textContent = jumpHeightSlider.value;
        };

        camHeightSlider.oninput = () => {
          camHeights[index] = parseFloat(camHeightSlider.value);
          document.getElementById(`p${index+1}CamHeightValue`).textContent = camHeightSlider.value;
        };
      });
      
      // Add trail duration control
      const trailSettingsDiv = document.createElement('div');
      trailSettingsDiv.className = 'trail-settings';
      trailSettingsDiv.innerHTML = `
        <h3>Trail Settings</h3>
        <div class="trail-duration">
          <label>Trail Duration (seconds):</label>
          <input type="range" id="trailDurationSlider" min="1" max="30" step="1" value="${trailDuration/1000}">
          <span id="trailDurationValue">${trailDuration/1000}</span>
        </div>
      `;
      playerSettings.appendChild(trailSettingsDiv);
      
      // Add event listener for trail duration
      const trailDurationSlider = document.getElementById('trailDurationSlider');
      trailDurationSlider.oninput = () => {
        const seconds = parseInt(trailDurationSlider.value);
        trailDuration = seconds * 1000;
        document.getElementById('trailDurationValue').textContent = seconds;
      };
    }

    // Initialize settings UI
    createPlayerSettingsUI();

    // Settings menu visibility
    document.getElementById('settingsGear').onclick = () => {
      const menu = document.getElementById('settingsMenu');
      menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    };

    // Save settings
    document.getElementById('saveSettingsBtn').onclick = () => {
      // Clear all existing trails when settings are saved
      trailSegments.forEach(trail => {
        scene.remove(trail);
      });
      trailSegments.length = 0; // Clear the array
      
      // Hide settings menu
      document.getElementById('settingsMenu').style.display = 'none';
    };

    // Start game
    document.getElementById('startBtn').onclick = () => {
      document.getElementById('startOverlay').style.display = 'none';
      gameState = 'running';
      
      // Notify all controllers about game state change
      notifyControllers({
        type: 'gameStatus',
        gameState: gameState
      });
    };

    // Game over
    function endGame(winner) {
      gameOver = true;
      gameState = 'gameover';
      document.getElementById('gameOverOverlay').style.display = 'flex';
      
      // Notify all controllers about game over
      notifyControllers({
        type: 'gameStatus',
        gameState: gameState,
        winner: winner ? winner.replace('p', '') : null
      });
    }

    // Retry
    document.getElementById('retryBtn').onclick = () => {
      window.location.reload();
    };

    // Pause/Resume
    document.getElementById('pauseBtn').onclick = () => {
      if (gameState === 'running') {
        gameState = 'paused';
        
        // Notify all controllers about game state change
        notifyControllers({
          type: 'gameStatus',
          gameState: gameState
        });
      }
    };

    document.getElementById('resumeBtn').onclick = () => {
      if (gameState === 'paused') {
        gameState = 'running';
        
        // Notify all controllers about game state change
        notifyControllers({
          type: 'gameStatus',
          gameState: gameState
        });
      }
    };

    // Restart
    document.getElementById('restartBtn').onclick = () => {
      window.location.reload();
    };

    // Exit
    document.getElementById('exitBtn').onclick = () => {
      window.location.href = 'playerSetup.html';
    };

    // Obstacle color picker
    document.getElementById('obsColorPicker').oninput = () => {
      obsColor = parseInt(document.getElementById('obsColorPicker').value.slice(1), 16);
      obstacles.forEach(o => o.material.color.set(document.getElementById('obsColorPicker').value));
    };

    // Arena size slider
    document.getElementById('arenaSizeSlider').oninput = () => {
      BOX = parseInt(document.getElementById('arenaSizeSlider').value);
      half = BOX / 2;
      document.getElementById('arenaSizeValue').textContent = BOX;
      
      // Update boundary
      boundary.geometry.dispose();
      boundary.geometry = new THREE.BoxGeometry(BOX, BOX, BOX);
      boundary.position.set(0, half - 0.5, 0);
      
      // Update grid helper
      scene.remove(gridHelper);
      gridHelper.geometry.dispose();
      gridHelper = new THREE.GridHelper(BOX, BOX / 10, 0x00ffff, 0x222222);
      scene.add(gridHelper);
      
      // Regenerate obstacles
      generateObstacles();
    };

    // Camera zoom slider
    document.getElementById('cameraZoomSlider').oninput = () => {
      camDistance = parseFloat(document.getElementById('cameraZoomSlider').value);
      document.getElementById('cameraZoomValue').textContent = camDistance;
    };

    // Obstacle density
    document.getElementById('levelSelect').onchange = () => {
      obstaclePercent = parseInt(document.getElementById('levelSelect').value);
      generateObstacles();
    };

    // Background selection
    const bgSelect = document.getElementById('bgSelect');
    const bgFiles = [];
    for (let i = 1; i <= 23; i++) {
      bgFiles.push(`bg_ (${i}).jpeg`, `bg_ (${i}).jpg`);
    }
    bgFiles.forEach(fn => {
      const opt = document.createElement('option');
      opt.value = fn;
      opt.textContent = fn;
      bgSelect.appendChild(opt);
    });
    bgSelect.onchange = () => {
      const val = bgSelect.value;
      if (val === 'none') {
        document.body.style.backgroundImage = 'none';
      } else {
        document.body.style.backgroundImage = `url("assets/${val}")`;
      }
    };

    // Initialize game state
    gameState = 'start';
    document.getElementById('startOverlay').style.display = 'flex';
    document.getElementById('gameOverOverlay').style.display = 'none';
    document.getElementById('settingsMenu').style.display = 'none';

    // Check if all players are keyboard players - auto-start if so
    const allKeyboard = players.every(p => p.type === 'keyboard');
    if (allKeyboard) {
      document.getElementById('startBtn').onclick();
    }

    // Initialize scoreboard
    updateScoreboard();

    // Start animation
    animate();

    // Function to notify all controllers about game state changes
    function notifyControllers(message) {
      players.forEach((player, index) => {
        if (player.type === 'phone') {
          notifyController(index, message);
        }
      });
    }
    
    // Function to notify a specific controller
    function notifyController(playerIndex, message) {
      if (channels[playerIndex]) {
        channels[playerIndex].postMessage(message);
      }
    }

    // Add CSS for settings and keybindings
    const style = document.createElement('style');
    style.textContent = `
      #settingsMenu {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #0ff;
        border-radius: 10px;
        padding: 20px;
        color: #0ff;
        z-index: 900;
        max-height: 80vh;
        overflow-y: auto;
        width: 80%;
        max-width: 600px;
      }

      #keyBindingsOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: 'Share Tech Mono', monospace;
      }
      
      #keyBindingsModal {
        background: #000;
        border: 2px solid #0ff;
        border-radius: 15px;
        padding: 30px;
        max-width: 800px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        color: #0ff;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      }
      
      #keyBindingsModal h2 {
        text-align: center;
        margin: 0 0 20px 0;
        color: #0ff;
        text-shadow: 0 0 10px #0ff;
        font-size: 24px;
      }
      
      .player-keybindings {
        margin-bottom: 25px;
        padding: 20px;
        border: 1px solid #0ff;
        border-radius: 10px;
        background: rgba(0, 255, 255, 0.05);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.1) inset;
      }
      
      .player-keybindings h3 {
        margin: 0 0 15px 0;
        color: #0ff;
        text-shadow: 0 0 5px #0ff;
        font-size: 20px;
        border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        padding-bottom: 10px;
      }
      
      .keybinding-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 12px 0;
        padding: 8px 15px;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 8px;
        border: 1px solid rgba(0, 255, 255, 0.1);
      }
      
      .keybinding-row span {
        font-size: 16px;
        color: rgba(0, 255, 255, 0.9);
      }
      
      .key-button {
        background: rgba(0, 255, 255, 0.1);
        border: 1px solid #0ff;
        color: #0ff;
        padding: 8px 20px;
        border-radius: 8px;
        cursor: pointer;
        min-width: 140px;
        text-align: center;
        font-size: 16px;
        transition: all 0.3s ease;
        text-transform: uppercase;
      }
      
      .key-button:hover {
        background: rgba(0, 255, 255, 0.2);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      }
      
      .key-button.waiting-for-key {
        background: rgba(255, 255, 0, 0.2);
        border-color: #ff0;
        color: #ff0;
        animation: pulse 1s infinite;
      }
      
      @keyframes pulse {
        0% { opacity: 1; box-shadow: 0 0 15px rgba(255, 255, 0, 0.3); }
        50% { opacity: 0.5; box-shadow: 0 0 25px rgba(255, 255, 0, 0.5); }
        100% { opacity: 1; box-shadow: 0 0 15px rgba(255, 255, 0, 0.3); }
      }
      
      .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 25px;
        padding-top: 20px;
        border-top: 1px solid rgba(0, 255, 255, 0.3);
      }
      
      .modal-buttons button {
        background: rgba(0, 255, 255, 0.1);
        border: 2px solid #0ff;
        color: #0ff;
        padding: 12px 25px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
        min-width: 150px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      
      .modal-buttons button:hover {
        background: rgba(0, 255, 255, 0.2);
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        transform: translateY(-2px);
      }
      
      #saveKeyBindingsBtn {
        background: rgba(0, 255, 255, 0.2);
      }
      
      #resetDefaultsBtn {
        background: rgba(255, 165, 0, 0.1);
        border-color: #ffa500;
        color: #ffa500;
      }
      
      #cancelKeyBindingsBtn {
        background: rgba(255, 0, 0, 0.1);
        border-color: #f00;
        color: #f00;
      }
      
      /* Scrollbar styling */
      #keyBindingsModal::-webkit-scrollbar {
        width: 10px;
      }
      
      #keyBindingsModal::-webkit-scrollbar-track {
        background: rgba(0, 255, 255, 0.1);
        border-radius: 5px;
      }
      
      #keyBindingsModal::-webkit-scrollbar-thumb {
        background: rgba(0, 255, 255, 0.3);
        border-radius: 5px;
        border: 1px solid rgba(0, 255, 255, 0.5);
      }
      
      #keyBindingsModal::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 255, 255, 0.4);
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>